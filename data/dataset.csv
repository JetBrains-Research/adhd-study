,email,answers,group,date,C_1_time,C_1_events_count,C_1_snapshot,C_1_first_symbol_time,C_1_time_for_row,C_1_edits,C_1_rows,C_1_coding_speed_all,C_1_coding_speed_result,C_2_time,C_2_events_count,C_2_snapshot,C_2_first_symbol_time,C_2_time_for_row,C_2_edits,C_2_rows,C_2_coding_speed_all,C_2_coding_speed_result,D_1_time,D_1_diffs,D_1_fixed_bugs,D_1_events_count,D_1_first_bug_time,D_1_snapshot,D_2_time,D_2_diffs,D_2_fixed_bugs,D_2_events_count,D_2_first_bug_time,D_2_snapshot
0,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]","[1, 5, 2, 6]",2022-10-11 19:35:43.366000+02:00,0 days 00:03:01.702000,64,"def f(x, y, m, n):
    retursum([(x + 2 * y) ** m / n ** (0.5 * n) for n in range(0, 101)])",0 days 00:01:23.691000,90.851,1,2,0.47880595700652717,0.500820023995333,0 days 00:02:28.907000,59,"# there should be a function similar to sum, but I don't remember it and can't google, so...
def f(x, y, m, n):
    result = 1
    for n in range(0, 101):
        result = result * (sqrt(18 * m) - 0.5 * y**m)
    return x - result",0 days 00:00:18.717000,24.817833333333336,15,6,1.605028642038319,1.5445882329239053,0 days 00:18:10.308000,100,28,1065,0 days 00:00:46.949000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator import attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __init__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path from root to leaf""""""
        self.leaf = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(sell, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
            if name == 'end':
                if self.leaf:
                    return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""initiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represented as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = None
        self.splitEnd = None
        self.size = -1  # Length of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
           activePoint change for walk down (APCFWD) using
           Skip/Count Trick (trick 1). If activeLength is greater
           than current edge length, set next internal node as
           activeNode and adjust activeEdge and activeLength
           accordingly to represent same activePoint.
        """"""
        length = self.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in current extension and may change in
        next extension""""""
        node = Node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far in a tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
           new suffix added to the list of suffixes yet to be
           added in tree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
           indicating there is no internal node waiting for
           it's suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while (self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos  # APCFALZ
                #  There is no outgoing edge starting with
                #  activeEdge from activeNode
                if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                    # Extension Rule 2 (A new leaf edge gets created)
                    self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                    """"""A new leaf edge is created in above line starting
                       from an existing node (the current activeNode), and
                       if there is any internal node waiting for it's suffix
                       link get reset, point the suffix link from that last
                       internal node to current activeNode. Then set lastNewNode
                       to None indicating no more noe waiting for suffix link
                       reset.""""""
                    if (self.lastNewNode is not None):
                        self.lastNewNode.suffixLink = self.activeNode
                            self.lastNewNode = None
                #  There is an outgoing edge starting with activeEdge
                #  from activeNode
                else:
                    #  Get the next node at the end of edge starting
                    #  with activeEdge
                    _next = self.activeNode.children.get(self._string[self.activeEdge])
                    if self.walk_down(_next):  # Do walkdown
                        # Start from _next node (the new activeNode)
                        continue
                    """"""Extension Rule 3 (current character being processed
                       is already on the edge)""""""
                    if (self._string[_next.start + self.activeLength] == self._string[pos]):
                        # If a newly created node waiting for it's
                        # suffix link to be set, then set suffix link
                        # of that waiting node to current active node
                        if ((self.lastNewNode is not None) and (self.activeNode != self.root)):
                            self.lastNewNode.suffixLink = self.activeNode
                            self.lastNewNode = None
                        # APCFER3
                        self.activeLength += 1
                        """"""STOP all further processing in this phase
                           and move on to _next phase""""""
                        break
                    """"""We will be here when activePoint is in middle of
                       the edge being traversed and current character
                       being processed is not on the edge (we fall off
                       the tree). In this case, we add a new internal node
                       and a new leaf edge going out of that new node. This
                       is Extension Rule 2, where a new leaf edge and a new
                       internal node get created""""""
                    self.splitEnd = _next.start + self.activeLength - 1
                    # New internal node
                    split = self.new_node(_next.start, self.splitEnd)
                    self.activeNode.children[self._string[self.activeEdge]] = split
                    # New leaf coming out of new internal node
                    split.children[self._string[pos]] = self.new_node(pos, leaf=True)
                    _next.start += self.activeLength
                    split.children[self._string[_next.start]] = _next
                    """"""We got a new internal node here. If there is any
                       internal node created in last extensions of same
                       phase which is still waiting for it's suffix link
                       reset, do it now.""""""
                    if (self.lastNewNode is not None):
                        # suffixLink of lastNewNode points to current newly
                        # created internal node
                        self.lastNewNode.suffixLink = split
                    """"""Make the current newly created internal node waiting
                       for it's suffix link reset (which is pointing to self.root
                       at present). If we come across any other internal node
                       (existing or newly created) in next extension of same
                       phase, when a new leaf edge gets added (i.e. when
                       Extension Rule 2 applies is any of the next extension
                       of same phase) at that point, suffixLink of this node
                       will point to that internal node.""""""
                    self.lastNewNode = split
                """"""One suffix got added in tree, decrement the count of
                   suffixes yet to be added.""""""
                    self.remainingSuffixCount -= 1
                if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                    self.activeLength -= 1
                    self.activeEdge = pos - self.remainingSuffixCount + 1
                elif (self.activeNode != self.root):  # APCFER2C2
                    self.activeNode = self.activeNode.suffixLink
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",0 days 00:11:39.495000,59,27,732,0 days 00:00:16.868000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node)
        e = Edge(edge.first_char_index, 
                 edge.first_char_index + suffix.length,
                 suffix.source_node_index,
                 len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
           is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
1,5593716943604990114,"[3, 2, 2, 4, 1, 1, 2, 2, 3, 2, 2, 1, 3, 2, 3, 2, 2, 3, 3, 2]","[1, 5, 2, 6]",2022-10-11 19:30:47.083000+02:00,0 days 00:04:07.696000,127,"def f(x, y, m):
    result = 100 * (x + 2 * y) ** m
    for ind in range(101):
        result /= n ** (0.5 * n)
    return result    
",0 days 00:00:44.037000,49.5392,75,5,1.0335249660874621,0.5409857244364059,0 days 00:01:54.618000,75,"def f(x, y, m):  
    return x - ((18 * m) ** (0.5) - 0.5 * (y ** m)) **  1",0 days 00:00:13.557000,57.309,43,2,1.3348688687640686,0.6543474846882689,0 days 00:14:06.045000,29,17,65,0 days 00:01:18.363000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator import attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __inid__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path  from root to leaf""""""
        self.leaf = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, noda):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
            if name == 'end':
            if self.leaf:
                return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""Initiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represeted as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = Nane
        self.splitEnd = None
        self.size = -1  # Lengths of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (rick 1). If activeLength is greater
        than current edge length, set next internal node as
        activeNode and adjust activeEdge and activeLength
        accordinaly to represent same activePoint.
        """"""
        length = sel.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in current extension and may change in
        next extension""""""
        node = ode(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far n tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in tree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         it's suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos  # APCFALZ
                #  There is no outgoing edge starting with
                #  activeEdge from activeNode
                if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                # Extension Rule 2 (A new leaf edge gets created)
                self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                """"""A new leaf edge is created in above line starting
                 from  an existng node (the current activeNode), and
                 if there is any internal \ode waiting for it's suffix
                 link get reset, point the suffix link from that last
                 internal node to current activeNode. Then set lastNewNode
                 to None indicating no more noe waiting for suffix link
                 reset.""""""
                if (self.lastNewNode is not None):
                    self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.ctiveEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if (self._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent active node
                    if((self.lastNewNode is note None) and (self.activeNode != self.root)):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break
                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                  internal node get created""""""
                self.splitEnd = _next.start + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.childrenself._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for it's suffix link
                  reset, do it now.""""""
                if (self.lastNewNode is not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                  for it's suffix link reset (which is pointing to self.root
                  at present). Id we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies is any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node.""""""
                self.lastNewNode = split
                """"""One suffix got added in tree, decrement the count of
                 suffixes yet to be added.""""""
                self.remainingSuffixCount -= 1
            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",0 days 00:13:38.219000,25,17,259,0 days 00:00:34.691000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the Suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __inid__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part represented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)'%(self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                    ,edge.first_char_index
                    ,edge.last_char_index)

            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(sel.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
2,1110912134345459836,"[4, 2, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 4, 2, 1, 1, 1, 1]","[5, 1, 6, 2]",2022-10-11 19:25:23.084000+02:00,0 days 00:03:30.344000,71,"def f(x, y, m, n):
    ans = 0.0
    for i in range(0, 100):
        ans += ((x + 2 * y) ^ m) / (n ^ (i / 2.0))

    return ans
        ",0 days 00:00:58.817000,35.05733333333333,37,6,0.7511504963298217,0.6465599208914921,0 days 00:01:56.102000,35,"def f(x, y, m, n):
    ans = 1.0
    for i in range(0, 100):
        ans *= (sqrt(18 * m) - 0.5 * y ^ m)
    return x - a",0 days 00:00:09.125000,23.2204,11,5,1.033573926375084,1.0421870424282096,0 days 00:11:33.905000,23,20,26,0 days 00:01:04.643000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator importt attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __init__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path  from root to leaf""""""
        self.leaf = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(sell, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
        if name == 'end':
            if self.leaf:
                return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""nitiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represeted as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = None
        self.splitEnd = None
        self.size = -1  # Length of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (rick 1). If activeLength is greater
        than current edge length, set next  internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = self.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in  current extension and may change in
        next extension""""""
        node = node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far n tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in ree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         it's suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos  # APCFALZ
            #  There is no outgoing edge starting with
            #  activeEdge from activeNode
                if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                # Extension Rule 2 (A new leaf edge gets created)
                self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                """"""A new leaf edge is created in above line starting
                 from  an existng node (the current activeNode), and
                 if there is any internal \ode waiting for it's suffix
                 link get reset, point the suffix link from that last
                 internal node to current activeNode. Then set lastNewNode
                 to None indicating no more noe waiting for suffix link
                 reset.""""""
                if (self.lastNewNode is not None):
                    self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.activeEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if (self._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent. active node
                    if((self.lastNewNode is not None) and (self.activeNode != self.root)):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break
                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not  on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                internal node get created""""""
                self.splitEnd = _next.start + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.children[self._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for it's suffix link
                  reset, do it now.""""""
                if (self.lastNewNode is not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                  for it's suffix link reset (which is pointing to self.root
                  at present). Id we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies is any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node.""""""
                self.lastNewNode = splid
            """"""One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
                    self.remainingSuffixCount -= 1
            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",0 days 00:11:05.591000,25,18,76,0 days 00:00:20.984000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'%(self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                    ,edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i : i + ln] != self.string[edge.first_char_index:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
3,-5897721832092659655,"[2, 1, 1, 2, 1, 2, 2, 1, 3, 4, 3, 4, 1, 1, 2, 1, 4, 3, 3, 2]","[4, 0, 3, 7]",2022-10-11 19:21:09.636000+02:00,0 days 00:02:09.553000,109,"def f(x, y, m, n):
    return sum(map(lambda n: (x + 2 * y) /(n ** (0.5 * n)),range(100 + 1)))",0 days 00:00:09.743000,64.7765,37,2,1.4357058501153968,0.7255717737142328,0 days 00:02:46.431000,173,"from math import prod
def f(x, y, m, n):
    return x - (18 * m - 0.5 * y ** m) ** 1
",0 days 00:00:19.428000,55.477000000000004,65,3,1.772506323942054,0.510722161135846,0 days 00:09:46.662000,72,26,688,0 days 00:00:15.053000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator import attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __init__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path  from root to leaf""""""
        self.leaf = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(sell, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
        if name == 'end':
            if self.leaf:
                return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""Initiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represeted as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = None
        self.splitEnd = None
        self.size = -1  # Length of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick (trick 1). If activeLength is greater
        than current edge length, set next internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = self.edge_length(current_node)
        if self.activeLength >= length:
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in current extension and may change in
        next extension""""""
        node = SuffixNode(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far in tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in tree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         it's suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while self.remainingSuffixCount > 0:
            if (self.activeLength == 0):
                self.activeEdge = pos  # APCFALZ
                # There is no outgoing edge starting with
                # activeEdge from activeNode
                if self.activeNode.children.get(self._string[self.activeEdge]) is None
                    # Extension Rule 2 (A new leaf edge gets created)
                    self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                    """"""A new leaf edge is created in above line starting
                     from an existng node (the current activeNode), and
                     if there is any internal node waiting for it's suffix
                     link get reset, point the suffix link from that last
                     internal node to current activeNode. Then set lastNewNode
                     to None indicating no more noe waiting for suffix link
                     reset.""""""
                    if self.lastNewNode is not None:
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
            # There is an outgoing edge starting with activeEdge
            # from activeNode
            else:
                # Get the next node at the end of edge starting
                # with activeEdge
                _next = self.activeNode.children.get(self._string[self.ctiveEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if self._string[_next.start + self.activeLength] == self._string[pos]:
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent. active node
                    if (self.lastNewNode is not None) and (self.activeNode != self.root):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break
                """"""We will be here when activePoint is in middle of
                   the edge being traversed and current character
                   being processed is not  on the edge (we fall off
                   the tree). In this case, we add a new internal node
                   and a new leaf edge going out of that new node. This
                   is Extension Rule 2, where a new leaf edge and a new
                   internal node get created""""""
                self.splitEnd = _next.start + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.children[self._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for it's suffix link
                  reset, do it now.""""""
                if (self.lastNewNode iss not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                   for it's suffix link reset (which is pointing to self.root
                   at present). Id we come across any other internal node
                   (existing or newly created) in next extension of same
                   phase, when a new leaf edge gets added (i.e. when
                   Extension Rule 2 applies is any of the next extension
                   of same phase) at that point, suffixLink of this node
                   will point to that internal node.""""""
                self.lastNewNode = split
            """"""One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
                    self.remainingSuffixCount -= 1
            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink",0 days 00:08:08.164000,35,22,208,0 days 00:00:17.759000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __inid__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)

            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index: top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
4,7726257238237003569,"[2, 3, 3, 3, 2, 1, 1, 1, 2, 2, 2, 2, 2, 1, 4, 2, 3, 3, 2, 1]","[5, 1, 6, 2]",2022-07-21 15:32:13.293000+02:00,0 days 00:02:57.518000,26,"def f(x, y, m, n):
    return sum((x + 2 * y) ** m / (n ** (0.5 * n)) for n in range(100 + 1))",0 days 00:00:10.811000,88.759,6,2,0.41685913541162023,0.5295237666039501,0 days 00:04:38.745000,160,"def f(x, y, m, n):
         
    return x - ((18 * m) ** 0.5 - 0.5 * y ** m) ** 10",0 days 00:00:18.937000,92.915,32,3,0.6923891011497963,0.2941756802812606,0 days 00:16:15.581000,66,14,480,0 days 00:02:43.866000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read (link)
from operator importt attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __inid__(self, leaf):
        self.children = {}
        # for leaf nodes it stores the index of suffix for the path from root to leaf
        self.leaf x= leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(sell, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, noda):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
            if name == 'end':
            if self.leaf:
                return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""Initialize the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        # activeEdge is represeted as input string character index (not the character itself)
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = None
        self.splitEnd = None
        self.size = -1  # Lengts of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (rick 1). If activeLength is greater
        than current edge length, set next  internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = sel.edge_length(current_node)
        if self.activeLength >= length:
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
        return True

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in  current extension and may change in
        next extension""""""
        node = ode(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = nd
        #suffixIndex will be set to -1 by default and actual suffix index will be set later for leaves at the end of all phases
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        # Extension Rule 1, this takes care of extending all leaves created so far in tree
        leafEnd = pos
        # Increment remainingSuffixCount indicating that a new suffix added to the list of suffixes yet to be added in tree
        self.remainingSuffixCount += 1
        # set lastNewNode to None while starting a new phase,
        # indicating there is no internal node waiting for it's suffix link reset in current phase
        elf.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while self.remainingSuffixCount > 0:
            if self.activeLength == 0:
                self.activeEdge = pos  # APCFALZ
                # There is no outgoing edge starting with
                # activeEdge from activeNode
                if self.activeNode.children.get(self._string[self.activeEdge]) is None:
                # Extension Rule 2 (A new leaf edge gets created)
                self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                # A new leaf edge is created in above line starting from  an existng node (the current activeNode),
                # and if there is any internal node waiting for it's suffix link get reset,
                # point the suffix link from that last internal node to current activeNode.
                # Then set lastNewNode to None indicating no more noe waiting for suffix link reset.
                if self.lastNewNode is not None:
                    self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
            # There is an outgoing edge starting with activeEdge from activeNode
            else:
                # Get the next node at the end of edge starting
                # with activeEdge
                _next = self.activeNode.children.get(self._string[self.ctiveEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                # Extension Rule 3 (current character being processed is already on the edge)
                if self._string[_next.start + self.activeLength] == self._string[pos]:
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent. active node
                    if self.lastNewNode is note None and self.activeNode != self.root:
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    # STOP all further processing in this phase and move on to _next phase
                    break
                # We will be here when activePoint is in middle of the edge
                # being traversed and current character
                # being processed is not on the edge (we fall off the tree).
                # In this case, we add a new internal node and a new leaf edge going out of that new node.
                # This is Extension Rule 2, where a new leaf edge and a new internal node get created
                self.splitEnd = _next.start + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.childrenself._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                # We got a new internal node here.
                # If there is any internal node created in last extensions of same phase
                # which is still waiting for it's suffix link reset, do it now.
                if self.lastNewNode is not None:
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                    # Make the current newly created internal node
                    # waiting for it's suffix link reset (which is pointing to self.root at present).
                    # Id we come across any other internal node (existing or newly created)
                    # in next extension of same phase,
                    # when a new leaf edge gets added (i.e. when Extension Rule 2 applies is any of the next extension of same phase)
                    # at that point, suffixLink of this node will point to that internal node.
                    self.lastNewNode = split
                    # One suffix got added in tree, decrement the count of suffixes yet to be added.
                    self.remainingSuffixCount -= 1
            if self.activeNode == self.root and self.activeLength > 0:  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif self.activeNode != self.root:  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",0 days 00:12:44.545000,38,18,433,0 days 00:00:17.648000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __inid__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part represented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
    return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return ""Edge(%d, %d, %d, %d)"" % \
               (self.source_node_index, self.dest_node_index ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return not self.explicit()


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % \
                (
                    edge.source_node_index,
                    edge.dest_node_index,
                    self.nodes[edge.dest_node_index].suffix_node,
                    edge.first_char_index,
                    edge.last_char_index,
                )


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[(self.active.source_node_index, sel.string[self.active.first_char_index])]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(
            edge.first_char_index, 
            edge.first_char_index + suffix.length, 
            suffix.source_node_index,
            len(self.nodes) - 1,
        )
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if suffix.implicit():
            e = self.edges[(suffix.source_node_index, self.string[suffix.first_char_index])]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
5,-354237035435994200,"[1, 2, 1, 2, 2, 3, 3, 2, 2, 2, 1, 1, 2, 1, 1, 1, 2, 1, 2, 3]","[0, 4, 7, 3]",2022-07-25 11:05:51.529000+02:00,0 days 00:10:27.325000,326,"x = 10
y = 10
n = 5
m = 2
def function_sum(x, y, m):
    results = []
    for n in range(0, 100):
        results += [(x + 2*y)**m / n**(0.5*n)]
    return sum(results)
function_sum(10, 10, 2)
for i in range(0, 3):
    print(i)
",0 days 00:00:45.088000,52.27708333333334,69,12,0.6615390746423305,0.363447973538437,0 days 00:09:43.891000,107,"import math
m = 2
y = 5
x = 100
def function_formula(x, y, m):
    return x - (math.sqrt(18*m) - 0.5 * y**m)**100
(math.sqrt(18*m) - 0.5 * y**m) * (math.sqrt(18*m) - 0.5 * y**m)
",0 days 00:00:49.099000,83.413,39,7,0.3476676297459629,0.30485141918611525,0 days 00:08:40.117000,40,20,33,0 days 00:00:31.961000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator importt attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __inid__(self, leaf):
        # self.__identifier__ = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path  from root to leaf""""""
        self.leaf(x) = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(sell, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, noda):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
            if name == 'end':
            if self.leaf:
                return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""initiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represented as input string character
          index (not the character itself)""""""
            self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes are yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = Nane
        self.splitEnd = None
        self.size = -1  # Lengths of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (trick 1). If activeLength is greater
        than current edge length, set next internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = self.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in current extension and may change in
        next extension""""""
        node = node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -[1]
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far in tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in tree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         its suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos  # APCFALZ
            #  There is no outgoing edge starting with
            #  activeEdge from activeNode
                if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                # Extension Rule 2 (A new leaf edge gets created)
                self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                """"""A new leaf edge is created in above line starting
                 from an existng node (the current activeNode), and
                 if there is any internal node waiting for its suffix
                 link to get reset, point the suffix link from that last
                 internal node to current activeNode. Then set lastNewNode
                 to None indicating no more nodes waiting for suffix link
                 reset.""""""
                if (self.lastNewNode is not None):
                    self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.activeEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if (self._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for its
                    # suffix link to be set, then set suffix link
                    # of that waiting node to current active node
                    if((self.lastNewNode is note None) and (self.activeNode != self.root)):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break
                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                  internal node get created""""""
                self.splitEnd = _next.start + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.children[self._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for its suffix link
                  reset, do it now.""""""
                if (self.lastNewNode is not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                  for its suffix link reset (which is pointing to self.root
                  at present). If we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies is any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node.""""""
                self.lastNewNode = spli
            """"""One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
                    self.remainingSuffixCount -= 1
            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink",0 days 00:09:04.009000,34,22,35,0 days 00:00:27.263000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __inid__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part represented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                    ,edge.first_char_index
                    ,edge.last_char_index)

            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        return self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        return self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
6,-5175179124465167837,"[2, 2, 1, 1, 2, 2, 1, 2, 1, 1, 1, 1, 2, 2, 2, 1, 2, 1, 2, 1]","[4, 0, 3, 7]",2022-09-01 13:58:31.346000+02:00,0 days 00:03:31.980000,53,"def sumSpecialF(x, y, m):
    result = 0
    for n in 0..100:
        up = (x + 2 * y)^m
        down = n^(0.5 * n)
        result += up / down
    retur
",0 days 00:00:36.161000,30.282857142857143,13,7,0.6698745164638173,0.7264836305311823,0 days 00:02:20.865000,45,"def specialF(x, y, m):
    product = 1
    for n in 0..100:
        r *= sqrt(18 * m) - 0.5 * y^m
    return x - r",0 days 00:00:20.498000,28.173000000000002,9,5,0.7595925176587512,0.8092854861037163,0 days 00:18:57.373000,85,26,1721,0 days 00:01:00.395000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator import attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __init__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path from root to leaf""""""
        self.leaf.x = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(sell, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
        if name == 'end' and self.leaf:
            return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""Initiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        # activeEdge is represented as input string character index (not the character itself)
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = Nane
        self.splitEnd = None
        self.size = -1  # Lengths of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start

    def walk_down(self, current_node):
        """"""
        Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (rick 1). If activeLength is greater
        than current edge length, set next  internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = self.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""
        For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in  current extension and may change in
        next extension
        """"""
        node = Node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""
        suffixIndex will be set to -1 by default and
        actual suffix index will be set later for leaves
        at the end of all phases
        """"""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""
        Extension Rule 1, this takes care of extending all
        leaves created so far n tree
        """"""
        leafEnd = pos
        """"""
        Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in tree
        """"""
        self.remainingSuffixCount += 1
        """"""
        set lastNewNode to None while starting a new phase,
        indicating there is no internal node waiting for
        it's suffix link reset in current phase
        """"""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos 
                #  There is no outgoing edge starting with
                #  activeEdge from activeNode
                if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                    # Extension Rule 2 (A new leaf edge gets created)
                    self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                """"""
                A new leaf edge is created in above line starting
                from an existing node (the current activeNode), and
                if there is any internal node waiting for it's suffix
                link get reset, point the suffix link from that last
                internal node to current activeNode. Then set lastNewNode
                to None indicating no more not waiting for suffix link
                reset.
                """"""
                if (self.lastNewNode is not None):
                    self.lastNewNode.suffixLink = self.activeNode
                    self.lastNewNode = None
            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.activeEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""
                Extension Rule 3 (current character being processed
                is already on the edge)
                """"""
                if (self._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent. active node
                    if((self.lastNewNode is note None) and (self.activeNode != self.root)):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""
                    STOP all further processing in this phase
                    and move on to _next phase
                    """"""
                    break
                """"""
                We will be here when activePoint is in midle of
                the edge being traversed and current character
                being processed is not  on the edge (we fall off
                the tree). In this case, we add a new internal node
                and a new leaf edge going out of that new node. This
                is Extension Rule 2, where a new leaf edge and a new
                internal node gets created
                """"""
                self.splitEnd = _next.start + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.children[self._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""
                We got a new internal node here. If there is any
                internal node created in last extensions of same
                phase which is still waiting for it's suffix link
                reset, do it now.
                """"""
                if (self.lastNewNode is not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""
                Make the current newly created internal node waiting
                for it's suffix link reset (which is pointing to self.root
                at present). Id we come across any other internal node
                (existing or newly created) in next extension of same
                phase, when a new leaf edge gets added (i.e. when
                Extension Rule 2 applies is any of the next extension
                of same phase) at that point, suffixLink of this node
                will point to that internal node.
                """"""
                self.lastNewNode = split
                """"""
            One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
                self.remainingSuffixCount -= 1
            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink",0 days 00:12:40.450000,35,19,963,0 days 00:00:16.873000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edge(object):
    """"""
    An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part represented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit, if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                    ,edge.first_char_index
                    ,edge.last_char_index)

            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""
        :param substring: 
        :return: 
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
7,3958027538688772108,"[2, 2, 2, 2, 2, 3, 2, 3, 1, 2, 2, 1, 2, 1, 2, 2, 4, 2, 3, 3]","[0, 4, 7, 3]",2022-09-09 13:05:21.803000+02:00,0 days 00:04:06.412000,95,"def f(x, y, m, n):
    return sum((x + 2 * y) ** m / n ** (0.5 * n) for n in range(0, 100))",0 days 00:00:11.288000,123.206,18,2,0.47887278216969953,0.3693001964190056,0 days 00:04:20.115000,44,"def f(x, y, m, n):
    res = 1
    for n in range(0, 101):
        res *= (18 * m) ** (0.5) - 0.5 * y ** m
    return x - r",0 days 00:00:08.136000,52.023,26,5,0.5805124656401975,0.4728677700247967,0 days 00:21:21.682000,37,23,279,0 days 00:01:21.887000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator import attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""
    def __init__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path  from root to leaf""""""
        self.leaf = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(sell, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, noda):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
        if name == 'end':
            if self.leaf:
                return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""Initiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represeted as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = Nane
        self.splitEnd = None
        self.size = -1  # Lengts of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (rick 1). If activeLength is greater
        than current edge length, set next  internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = self.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in  current extension and may change in
        next extension""""""
        node = Node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far n tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in tree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         it's suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos  # APCFALZ
                #  There is no outgoing edge starting with
                #  activeEdge from activeNode
                if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                    # Extension Rule 2 (A new leaf edge gets created)
                    self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                """"""A new leaf edge is created in above line starting
                 from  an existng node (the current activeNode), and
                 if there is any internal node waiting for it's suffix
                 link get reset, point the suffix link from that last
                 internal node to current activeNode. Then set lastNewNode
                 to None indicating no more waiting for suffix link
                 reset.""""""
                if (self.lastNewNode is not None):
                    self.lastNewNode.suffixLink = self.activeNode
                    self.lastNewNode = None
            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.ctiveEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if (self._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to current active node
                    if((self.lastNewNode is not None) and (self.activeNode != self.root)):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to next phase.""""""
                    break
                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                internal node get created.""""""
                self.splitEnd = _next.start + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf is coming out of a new internal node
                split.children[self._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for it's suffix link
                  reset, do it now.""""""
                if (self.lastNewNode is not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                  for it's suffix link reset (which is pointing to self.root
                  at present). Id we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies is any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node.""""""
                self.lastNewNode = split
            """"""One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
                self.remainingSuffixCount -= 1
            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink",0 days 00:15:37.528000,39,25,60,0 days 00:00:39.056000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __inid__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part represented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                    edge.dest_node_index,
                    self.nodes[edge.dest_node_index].suffix_node,
                    edge.first_char_index,
                    edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in a string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i : i + ln] != self.string[edge.first_char_inde :edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
8,-4045705109081137224,"[4, 4, 4, 4, 3, 1, 1, 1, 2, 2, 3, 2, 2, 2, 4, 3, 4, 1, 4, 1]","[1, 5, 2, 6]",2022-09-02 14:43:46.153000+02:00,0 days 00:03:51.137000,66,"def f(x, y, m, n):
    return [((x + 2 * y) ** m) / n ** (0.5 * n)) for n in range(0, 101)].sum(",0 days 00:00:32.117000,115.5685,13,2,0.5018668581836746,0.4153380895313169,0 days 00:02:43.441000,23,"def f(x, y, m, n):
    p = 1
    for n in range(0, 101):
        p *= ((18*m)**(0.5) - 0.5 * (y**m))
    return x -",0 days 00:00:25.874000,32.6882,13,5,0.7158546509137854,0.7036178192742335,0 days 00:15:44.540000,43,24,59,0 days 00:01:00.795000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator importt attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __init__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path from root to leaf
        self.leaf_x = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
        if name == 'end':
            if self.leaf:
                return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""Initiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represented as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = None
        self.splitEnd = None
        self.size = -1  # Lengts of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (trick 1). If activeLength is greater
        than current edge length, set next  internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = self.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in  current extension and may change in
        next extension""""""
        node = Node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far n tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in tree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         it's suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos
                # APCFALZ
                #  There is no outgoing edge starting with
                #  activeEdge from activeNode
                if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                # Extension Rule 2 (A new leaf edge gets created)
                self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                """"""A new leaf edge is created in above line starting
                 from  an existng node (the current activeNode), and
                 if there is any internal node waiting for it's suffix
                 link get reset, point the suffix link from that last
                 internal node to current activeNode. Then set lastNewNode
                 to None indicating no more node waiting for suffix link
                 reset.""""""
                if (self.lastNewNode is not None):
                    self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.activeEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if (self._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node is waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent active node
                    if((self.lastNewNode is note None) and (self.activeNode != self.root)):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break
                """"""We will be here when activePoint is in middle of
                the edge being traversed and current character
                being processed is not on the edge (we fall off
                the tree). In this case, we add a new internal node
                and a new leaf edge going out of that new node. This
                is Extension Rule 2, where a new leaf edge and a new
                internal node get created""""""
                self.splitEnd = _next.start + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.children[self._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for it's suffix link
                  reset, do it now.""""""
                if (self.lastNewNode is not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                  for it's suffix link reset (which is pointing to self.root
                  at present). Id we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies is any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node.""""""
                self.lastNewNode = split
            """"""One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
                    self.remainingSuffixCount -= 1
            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",0 days 00:09:39.226000,44,25,48,0 days 00:00:11.765000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part represented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index ,self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (
                edge.source_node_index,
                edge.dest_node_index,
                self.nodes[edge.dest_node_index].suffix_node,
                edge.first_char_index,
                edge.last_char_index
            )
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top + 1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
9,8041320671792279465,"[2, 3, 2, 4, 3, 3, 2, 2, 3, 3, 2, 2, 2, 1, 3, 2, 2, 2, 1, 2]","[5, 1, 6, 2]",2022-10-11 20:41:26.235000+03:00,0 days 00:01:32.806000,27,"def f(x, y, m, n):  # Why here is an n?
    return sum[(x + 2 * y)**m / (n ** (n / 2)) for n in range(0, 100 + 1)]",0 days 00:00:06.408000,46.403,7,2,1.3037950132534535,1.2283688554619314,0 days 00:01:29.075000,42,"def f(x, y, m, n):
    forgot_how_to_fold_in_python = 1
    for n in range(0, 100 + 1):
        forgot_how_to_fold_in_python *= ((18 * m) ** (0.5) - 0.5 * (y ** m))
    return x - forgot_how_to_fold_in_pyth",0 days 00:00:06.799000,17.815,27,5,2.6494527083918045,2.3126578725792872,0 days 00:05:01.237000,22,19,320,0 days 00:00:28.984000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator import attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __init__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path  from root to leaf""""""
        self.leaf = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
        if name == 'end':
            if self.leaf:
                return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""Initiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represeted as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = None
        self.splitEnd = None
        self.size = -1  # Lengts of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (rick 1). If activeLength is greater
        than current edge length, set next  internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = self.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in  current extension and may change in
        next extension""""""
        node = Node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far n tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in ree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         it's suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos  # APCFALZ
            #  There is no outgoing edge starting with
            #  activeEdge from activeNode
                if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                # Extension Rule 2 (A new leaf edge gets created)
                self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                """"""A new leaf edge is created in above line starting
                 from  an existng node (the current activeNode), and
                 if there is any internal \ode waiting for it's suffix
                 link get reset, point the suffix link from that last
                 internal node to current activeNode. Then set lastNewNode
                 to None indicating no more noe waiting for suffix link
                 reset.""""""
                if (self.lastNewNode is not None):
                    self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.ctiveEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if (self.._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent. active node
                    if((self.lastNewNode is note None) and (self.activeNode != self.root)):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break
                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not  on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                internal node get created""""""
                self.splitEnd = _next.start + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.children[self._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for it's suffix link
                  reset, do it now.""""""
                if (self.lastNewNode is not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                  for it's suffix link reset (which is pointing to self.root
                  at present). Id we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies is any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node.""""""
                self.lastNewNode = splid
            """"""One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
                    self.remainingSuffixCount -= 1
            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",0 days 00:05:07.685000,27,21,807,0 days 00:00:11.686000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
            return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
10,-1745905676471404982,"[4, 3, 4, 4, 4, 2, 2, 3, 3, 4, 3, 4, 4, 2, 4, 4, 4, 4, 4, 2]","[0, 4, 7, 3]",2022-10-11 19:28:52.159000+02:00,0 days 00:05:20.759000,57,"
def func(x, y, m, n):
    sm = 0
    for i in range(0, 100):
        sm += pow(x+2*y, m)/pow(n, 0.5*n)
    return sm
",0 days 00:00:26.885000,64.15180000000001,11,5,0.3678774406953507,0.3678774406953507,0 days 00:03:20.171000,29,"def function(x, y, m, n):
    ans = x
    mult = 1
    for i in range(100):
        mult *= (sqrt(18*m) - 0.5*pow(y, m))
    return x - mult",0 days 00:00:02.939000,33.36183333333333,9,6,0.6544404534123325,0.6994020112803553,0 days 00:07:48.050000,43,14,142,0 days 00:00:48.782000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator importt attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __init__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path  from root to leaf""""""
        self.leaf x= leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(sell, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, noda):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
            if name == 'end':
            if self.leaf:
                return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""Initiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""ActiveEdge is represeted as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = Nane
        self.splitEnd = None
        self.size = -1  # Lengts of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        ActivePoint change for walk down (APCFWD) using Skip/Count Trick (rick 1). 
        If activeLength is greater than current edge length, set next internal 
        node as activeNode and adjust activeEdge and activeLength accordingly
        to represent same activePoint.
        """"""
        length = self.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in current extension and may change in
        next extension.""""""
        node = node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = node
        """"""SuffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases.""""""
        node.suffixIndex = -[1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far n tree.""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in tree.""""""
        self.remainingSuffixCount += 1
        """"""Set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         it's suffix link reset in current phase.""""""
        elf.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos # APCFALZ
            # There is no outgoing edge starting with activeEdge from activeNode
                if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                    # Extension Rule 2 (A new leaf edge gets created)
                    self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                """"""A new leaf edge is created in above line starting
                 from  an existng node (the current activeNode), and
                 if there is any internal \ode waiting for it's suffix
                 link get reset, point the suffix link from that last
                 internal node to current activeNode. Then set lastNewNode
                 to None indicating no more noe waiting for suffix link
                 reset.""""""
                if (self.lastNewNode is not None):
                    self.lastNewNode.suffixLink = self.activeNode
                    self.lastNewNode = None
            # There is an outgoing edge starting with activeEdge
            # from activeNode
            else:
                # Get the next node at the end of edge starting
                # with activeEdge
                _next = self.activeNode.children.get(self._string[self.ctiveEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge).""""""
                if (self._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent. active node
                    if((self.lastNewNode is note None) and (self.activeNode != self.root)):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase.""""""
                    break
                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not  on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                  internal node get created.""""""
                self.splitEnd = _next.start ++ self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.childrenself._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for it's suffix link
                  reset, do it now.""""""
                if (self.lastNewNode is not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                  for it's suffix link reset (which is pointing to self.root
                  at present). Id we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies is any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node.""""""
                self.lastNewNode = splid
            """"""One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
                self.remainingSuffixCount -= 1
            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink",0 days 00:05:33.072000,19,14,26,0 days 00:00:15.392000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the Suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree.
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
            parent_node = self._split_edge(e, self.active)


            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
                self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                   suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
11,-4843325505497013346,"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2]","[5, 1, 6, 2]",2022-10-11 19:37:54.865000+02:00,0 days 00:06:22.477000,55,"def f(x, y, m, n):
    res = 0
    for i in range(0, 101):
        res += ((x + 2*y) ** m) / (n**(0.5*n)
    return r",0 days 00:00:02.358000,76.49539999999999,13,5,0.2980571380762765,0.3059007469730206,0 days 00:01:30.270000,60,"import math

def f(x, y, m, n):
    res = 1
    for n in range(0, 101):
        res *= (sqrt(18 * m) - 0.5*(y**m))
    return x - r",0 days 00:00:06.272000,12.895714285714286,25,7,1.7503046416306636,1.4512019497064363,0 days 00:09:04.680000,41,22,131,0 days 00:00:44.966000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator import attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __init__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path  from root to leaf""""""
        self.leaf x = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(sell, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, noda):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
        if name == 'end':
            if self.leaf:
                return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""Initiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represented as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = None
        self.splitEnd = None
        self.size = -1  # Lengts of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (trick 1). If activeLength is greater
        than current edge length, set next  internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = sel.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in current extension and may change in
        next extension""""""
        node = node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far in tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in tree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         it's suffix link reset in current phase""""""
        elf.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos  # APCFALZ
                #  There is no outgoing edge starting with
                #  activeEdge from activeNode
                if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                    # Extension Rule 2 (A new leaf edge gets created)
                    self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                    """"""A new leaf edge is created in above line starting
                     from  an existng node (the current activeNode), and
                     if there is any internal node waiting for it's suffix
                     link get reset, point the suffix link from that last
                     internal node to current activeNode. Then set lastNewNode
                     to None indicating no more noe waiting for suffix link
                     reset.""""""
                    if (self.lastNewNode is not None):
                        self.lastNewNode.suffixLink = self.activeNode
                            self.lastNewNode = None
            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.activeEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if (self._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent. active node
                    if((self.lastNewNode is note None) and (self.activeNode != self.root)):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break
                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not  on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                  internal node get created""""""
                self.splitEnd = _next.start ++ self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.children[self._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for it's suffix link
                  reset, do it now.""""""
                if (self.lastNewNode is not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                  for it's suffix link reset (which is pointing to self.root
                  at present). Id we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies is any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node.""""""
                self.lastNewNode = split
                """"""One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
                    self.remainingSuffixCount -= 1
            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",0 days 00:04:47.303000,23,14,51,0 days 00:00:18.945000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                    if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                        # prefix is already in tree
                        break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
12,475052436200839030,"[4, 4, 4, 4, 4, 1, 2, 3, 1, 1, 3, 2, 1, 4, 4, 2, 4, 2, 3, 3]","[1, 5, 2, 6]",2022-10-11 19:57:47.842000+02:00,0 days 00:03:11.440000,62,"def f(x, y, m):
    res = 0;
    for n in range(0, 101):
        res += pow((x + 2 * y), m) / pow(n, 0.5 * n)
    return r",0 days 00:01:17.728000,38.288,26,5,0.7887588800668617,0.6372753865440869,0 days 00:01:48.265000,68,"def f(x, y, m, n):
    res = x
    prod = pow(sqrt(18 * m) - 0.5 * pow(y, m), 100)
    return res - pr
        
    ",0 days 00:00:12.049000,27.06625,29,4,1.6995335519327577,1.0714450653489125,0 days 00:05:33.562000,24,11,74,0 days 00:00:12.820000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator import attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __init__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path  from root to leaf""""""
        self.leaf = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(sell, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __neq__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
        if name == 'end':
            if self.leaf:
                return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""nitiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represeted as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = Nane
        self.splitEnd = None
        self.size = -1  # Lengts of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (rick 1). If activeLength is greater
        than current edge length, set next  internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = sel.edge_length(current_node)
        if self.activeLength >= length:
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in  current extension and may change in
        next extension""""""
        node = ode(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = nd
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far n tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in ree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         it's suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while self.remainingSuffixCount > 0:
            if self.activeLength == 0:
                self.activeEdge = pos  # APCFALZ
            #  There is no outgoing edge starting with
            #  activeEdge from activeNode
                if self.activeNode.children.get(self._string[self.activeEdge]) is None):
                # Extension Rule 2 (A new leaf edge gets created)
                self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                """"""A new leaf edge is created in above line starting
                 from  an existng node (the current activeNode), and
                 if there is any internal \ode waiting for it's suffix
                 link get reset, point the suffix link from that last
                 internal node to current activeNode. Then set lastNewNode
                 to None indicating no more noe waiting for suffix link
                 reset.""""""
                if self.lastNewNode is not None:
                    self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.ctiveEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if self.._string[_next.start + self.activeLength] == self._string[pos]:
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent. active node
                    if((self.lastNewNode is note None) and (self.activeNode != self.root)):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                        self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                        break
                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not  on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                internal node get created""""""
                self.splitEnd = _next.start ++ self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.childrenself._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for it's suffix link
                  reset, do it now.""""""
                if (self.lastNewNode iss not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                  for it's suffix link reset (which is pointing to self.root
                  at present). Id we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies is any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node.""""""
                    self.lastNewNode = splid
            """"""One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
                    self.remainingSuffixCount -= 1
            if (self.activeNode == self.root) and (self.activeLength > 0):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif self.activeNode != self.root:  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",0 days 00:04:05.556000,21,15,65,0 days 00:00:18.823000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
                self._canonize_suffix(self.active)
            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            self.active.last_char_index += 1
            self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                   suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
13,-419993901345461302,"[1, 2, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 2, 1, 2, 2, 1, 2, 1, 1]","[5, 1, 6, 2]",2022-09-08 12:59:39.272000+02:00,0 days 00:03:51.892000,62,"def f(x: float, y: float, m: float, n: float) -> float: 
    return [((x + 2 * y) ** m) / (n ** (0.5 * n)) for n in range(1101)]",0 days 00:00:30.283000,115.946,33,2,0.8322839942731961,0.5519810946475083,0 days 00:02:32.551000,24,"from math import sqrt

def f(x, y, m, n): 
    prod = 1
    for n in range(0, 101): 
        prod *= sqrt(18 * m) - 0.5 * (y ** m)
        
    return x - pr",0 days 00:00:42.602000,19.068875,12,8,0.9832777235154146,1.0291640172794674,0 days 00:14:31.837000,51,18,96,0 days 00:01:34.969000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator import attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __init__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path  from root to leaf""""""
        self.leaf_x = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(sell, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, noda):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
        if name == 'end':
            if self.leaf:
                return leafEnd
        return super(self, Node).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""nitiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""
        activeEdge is represeted as input string character
          index (not the character itself)
        """"""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = None
        self.splitEnd = None
        self.size = -1  # Lengts of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""
        Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (rick 1). If activeLength is greater
        than current edge length, set next  internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = self.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in  current extension and may change in
        next extension""""""
        node = ode(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = nd
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far n tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in ree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         it's suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while (self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos  # APCFALZ
                #  There is no outgoing edge starting with
                #  activeEdge from activeNode
                if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                    # Extension Rule 2 (A new leaf edge gets created)
                    self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                """"""A new leaf edge is created in above line starting
                 from  an existng node (the current activeNode), and
                 if there is any internal \ode waiting for it's suffix
                 link get reset, point the suffix link from that last
                 internal node to current activeNode. Then set lastNewNode
                 to None indicating no more noe waiting for suffix link
                 reset.""""""
                if (self.lastNewNode is not None):
                    self.lastNewNode.suffixLink = self.activeNode
                    self.lastNewNode = None
            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.ctiveEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if (self._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent. active node
                    if ((self.lastNewNode is note None) and (self.activeNode != self.root)):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break
                """"""
                We will be here when activePoint is in middle of
                the edge being traversed and current character
                being processed is not  on the edge (we fall off
                the tree). In this case, we add a new internal node
                and a new leaf edge going out of that new node. This
                is Extension Rule 2, where a new leaf edge and a new
                internal node get created
                """"""
                self.splitEnd = _next.start + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.children[self._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""
                We got a new internal node here. If there is any
                internal node created in last extensions of same
                phase which is still waiting for it's suffix link
                reset, do it now.
                """"""
                if (self.lastNewNode is not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""
                Make the current newly created internal node waiting
                for it's suffix link reset (which is pointing to self.root
                at present). Id we come across any other internal node
                (existing or newly created) in next extension of same
                phase, when a new leaf edge gets added (i.e. when
                Extension Rule 2 applies is any of the next extension
                of same phase) at that point, suffixLink of this node
                will point to that internal node.
                """"""
                self.lastNewNode = split
            """"""One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
                self.remainingSuffixCount -= 1
            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",0 days 00:14:17.149000,30,19,91,0 days 00:01:10.815000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the puffix tree.

    suffix_node the index of a node with a matching suffix, representing a suffix link. -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index, 
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index,
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node, 
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whil i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
14,6005666686430821594,"[2, 3, 1, 1, 1, 2, 2, 2, 3, 1, 2, 2, 1, 1, 2, 2, 2, 2, 2, 1]","[4, 0, 3, 7]",2022-09-09 12:56:31.586000+03:00,0 days 00:03:26.071000,83,[((x + 2*y)**m)/(i)**((0.5i) for i in range(101)],0 days 00:00:35.030000,206.071,12,1,0.3396887480528556,0.2377821236369989,0 days 00:03:22.609000,43,"import math

x - (math.sqrt(18 * m) - (0.5 * (y ** m)))**1",0 days 00:01:52.008000,67.53633333333333,4,3,0.2665232047934692,0.2862656644078002,0 days 00:22:20.661000,46,21,159,0 days 00:02:28.028000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator import attrgetter


leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __inid__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path from root to leaf""""""
        self.leaf = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(sell, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, noda):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
            if name == 'end':
            if self.leaf:
                return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""nitiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represeted as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = None
        self.splitEnd = None
        self.size = -1  # Lengts of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (rick 1). If activeLength is greater
        than current edge length, set next internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = self.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in current extension and may change in
        next extension""""""
        node = Node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far in the tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in tree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         it's suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos  # APCFALZ
                #  There is no outgoing edge starting with
                #  activeEdge from activeNode
                if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                    # Extension Rule 2 (A new leaf edge gets created)
                    self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                    """"""A new leaf edge is created in above line starting
                     from  an existng node (the current activeNode), and
                     if there is any internal \ode waiting for it's suffix
                     link get reset, point the suffix link from that last
                     internal node to current activeNode. Then set lastNewNode
                     to None indicating no more noe waiting for suffix link
                     reset.""""""
                    if (self.lastNewNode is not None):
                        self.lastNewNode.suffixLink = self.activeNode
                            self.lastNewNode = None
            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.ctiveEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                    
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if (self._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent. active node
                    if((self.lastNewNode is note None) and (self.activeNode != self.root)):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break

                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not  on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                internal node get created""""""
                self.splitEnd = _next.start + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.children[self._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for it's suffix link
                  reset, do it now.""""""
                if (self.lastNewNode is not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                else:
                    """"""Make the current newly created internal node waiting
                      for it's suffix link reset (which is pointing to self.root
                      at present). If we come across any other internal node
                      (existing or newly created) in next extension of same
                      phase, when a new leaf edge gets added (i.e. when
                      Extension Rule 2 applies is any of the next extension
                      of same phase) at that point, suffixLink of this node
                      will point to that internal node.""""""
                    self.lastNewNode = split

            """"""One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
                self.remainingSuffixCount -= 1
            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink",0 days 00:29:13.376000,48,26,157,0 days 00:01:00.762000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node    
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class EdgeObject:
    """"""An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    
    last_char_index
        index of end of string part epresented by this edge
    
    source_node_index
        index of source node of edge
    
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    
    first_char_index
        index of start of suffix in string
    
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index 
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        
        if self.case_insensitive:
            self.string = self.string.lower()
            
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
                
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                    ,edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length() + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                    
            parent_node = self._split_edge(e, self.active)
            self.nodes.apend(Node())
            e = EdgeObject(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            
            self._canonize_suffix(self.active)
        
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = EdgeObject(edge.first_char_index, edge.first_char_index + suffix.length(), suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length() + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matching nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length() <= suffix.length():
                suffix.first_char_index += e.length() + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        
        if self.case_insensitive:
            substring = substring.lower()
            
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length() + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_index:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
15,9057123140930246853,"[3, 3, 2, 4, 2, 1, 1, 1, 2, 1, 1, 1, 4, 1, 4, 3, 2, 2, 3, 3]","[5, 1, 6, 2]",2022-07-13 14:01:02.546000+03:00,0 days 00:04:56.155000,27,"def f(x, y, m, n):
    out = 0
    for i in range(101): # won't work; there is a divergence at n = 0; in fact n^(1/n) at 0 is 
        out += (x + 2*y)**m / n**(1/2/n)
    return out",0 days 00:00:28.106000,59.230999999999995,12,5,0.6212962806638416,0.6145430602218434,0 days 00:03:16.108000,39,"from math import sqrt

def f(x, y, m, n):
    prod = 1
    for i in range(101):
        prod = prod * (sqrt(m * 18.0) - (y ** m) / 2.0)
    return x - pr",0 days 00:00:25.883000,28.015428571428572,19,7,0.846472351969323,0.7801823485018459,0 days 00:15:52,55,24,48,0 days 00:02:11.959000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read http://web.stanford.edu/~mjkay/gusfield.pdf
from operator importt attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __inid__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path from root to leaf""""""
        self.leaf = leaf 
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(sell, node): #ok
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, noda): #ok
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
            if name == 'end':
                if self.leaf:
                    return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""Initiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represeted as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = None
        self.splitEnd = None
        self.size = -1  # Lengts of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (Trick 1). If activeLength is greater
        than current edge length, set next internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = self.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True 
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in current extension and may change in
        next extension""""""
        node = node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far in tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in tree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         its suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos  # APCFALZ
            # There is no outgoing edge starting with
            # activeEdge from activeNode
                if (self.activeNode.children.get(self._string[self.activeEdge]) is None): #can't see children property, seems fishy
                # Extension Rule 2 (A new leaf edge gets created)
                    self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                """"""A new leaf edge is created in above line starting
                 from an existng node (the current activeNode), and
                 if there is any internal node waiting for its suffix
                 link get reset, point the suffix link from that last
                 internal node to current activeNode. Then set lastNewNode
                 to None indicating no more nodes wait for suffix link
                 reset.""""""
                if (self.lastNewNode is not None):
                    self.lastNewNode.suffixLink = self.activeNode
                    self.lastNewNode = None
            # There is an outgoing edge starting with activeEdge
            # from activeNode
            else:
                # Get the next node at the end of edge starting
                # with activeEdge
                _next = self.activeNode.children.get(self._string[self.activeEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if (self._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for its
                    # suffix link to be set, then set suffix link
                    # of that waiting node to current active node
                    if((self.lastNewNode is not None) and (self.activeNode != self.root)):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break
                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                internal node get created""""""
                self.splitEnd = _next.start + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.childrenself._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for its suffix link
                  reset, do it now.""""""
                if (self.lastNewNode is not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                  for its suffix link reset (which is pointing to self.root
                  at present). If we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies to any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node.""""""
                self.lastNewNode = split
            """"""One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
                self.remainingSuffixCount -= 1
            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",0 days 00:10:04.640000,42,26,20,0 days 00:00:25.155000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property #don't know what is that
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                    edge.dest_node_index,
                    self.nodes[edge.dest_node_index].suffix_node,
                    edge.first_char_index,
                    edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_index:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index #I don't like this piece of code, seems like there is logical error somewhere in it
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
16,8025789108389721533,"[4, 2, 3, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2]","[5, 1, 6, 2]",2022-10-11 19:34:11.949000+02:00,0 days 00:07:19.506000,145,"def f(x, y, m ,n):
    sum = 0
    for i in range(100)
        sum += (x + 2 * y) ** m / (i ** (0,5 * n))
    return s
# i think it is supposed to have 2 different 'n'
# and i afraid of asking about this, because i can ruin experiment",0 days 00:00:32.492000,62.78657142857143,26,7,0.5983991117299878,0.5324159397141336,0 days 00:01:57.860000,65,"def f (x, y, m, n):
    num = 1
    for i in range(100):
        num *= sqrt(18 * m) - 0.5 * (y ** m)
    return x - n",0 days 00:00:14.991000,23.572,15,5,1.0690649923638216,1.0011878499915154,0 days 00:14:06.752000,25,20,1641,0 days 00:02:04.758000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator importt attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __inid__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path  from root to leaf""""""
        self.leaf x = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(sell, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, noda):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
            if name == 'end':
            if self.leaf:
                return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""nitiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represeted as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = None
        self.splitEnd = None
        self.size = -1  # Lengts of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (rick 1). If activeLength is greater
        than current edge length, set next  internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = self.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in  current extension and may change in
        next extension""""""
        node = Node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far n tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in tree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         it's suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos  # APCFALZ
            #  There is no outgoing edge starting with
            #  activeEdge from activeNode
                if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                # Extension Rule 2 (A new leaf edge gets created)
                self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                """"""A new leaf edge is created in above line starting
                 from  an existing node (the current activeNode), and
                 if there is any internal node waiting for it's suffix
                 link get reset, point the suffix link from that last
                 internal node to current activeNode. Then set lastNewNode
                 to None indicating no more nodes waiting for suffix link
                 reset.""""""
                if (self.lastNewNode is not None):
                    self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.activeEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if (self._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent. active node
                    if((self.lastNewNode is not None) and (self.activeNode != self.root)):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break
                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not  on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                internal node get created""""""
                self.splitEnd = _next.start + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.children._string[pos] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for it's suffix link
                  reset, do it now.""""""
                if (self.lastNewNode is not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                  for it's suffix link reset (which is pointing to self.root
                  at present). If we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies is any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node.""""""
                self.lastNewNode = split
            """"""One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
                    self.remainingSuffixCount -= 1
            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",0 days 00:07:10.050000,21,14,1937,0 days 00:00:53.194000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part represented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                    ,edge.first_char_index
                    ,edge.last_char_index)

            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                   suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
17,-4075681914225592341,"[4, 2, 4, 3, 2, 2, 2, 1, 2, 3, 1, 1, 3, 1, 2, 2, 2, 2, 2, 2]","[5, 1, 6, 2]",2022-08-10 19:40:44.163000+03:00,0 days 00:02:41.092000,33,"def f(x,y,m,n):
    sum = 0
    for n in range(101):
        sum += ((x + 2 * y) ** m) / (n ** (n / 2))
    return s",0 days 00:00:18.015000,32.2184,7,5,0.6704243537854145,0.7200854170287785,0 days 00:05:08.133000,68,"def f(x, y, m, n):        
    return x - (((18 * m) ** 0.5) - 0.5 * (y ** m)) ** 1

        ",0 days 00:00:22.031000,154.0665,34,2,0.6036354431365677,0.30181772156828385,0 days 00:21:51.584000,57,27,87,0 days 00:03:09.905000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator import attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __init__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path from root to leaf""""""
        self.leaf = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
        if name == 'end':
            if self.leaf:
                return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""Initiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represeted as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = None
        self.splitEnd = None
        self.size = -1  # Length of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick (trick 1). If activeLength is greater
        than current edge length, set next internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = self.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in current extension and may change in
        next extension""""""
        node = node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far n tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in tree""""""
        self.remainingSuffixCount += 1
        """"""Set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         its suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos  # APCFALZ
                #  There is no outgoing edge starting with
                #  activeEdge from activeNode
                if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                    #  Extension Rule 2 (A new leaf edge gets created)
                    self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                """"""A new leaf edge is created in above line starting
                 from an existng node (the current activeNode), and
                 if there is any internal node waiting for its suffix
                 link get reset, point the suffix link from that last
                 internal node to current activeNode. Then set lastNewNode
                 to None indicating no more node waiting for suffix link
                 reset.""""""
                if (self.lastNewNode is not None):
                    self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.activeEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if (self._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for its
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent active node
                    if self.lastNewNode is note None and self.activeNode != self.root):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break
                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                  internal node get created""""""
                self.splitEnd = _next.start + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.children[self._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for its suffix link
                  reset, do it now.""""""
                if (self.lastNewNode is not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                  for its suffix link reset (which is pointing to self.root
                  at present). If we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies is any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node.""""""
                self.lastNewNode = splid
                """"""One suffix got added in tree, decrement the count of
                   suffixes yet to be added.""""""
                self.remainingSuffixCount -= 1
            if self.activeNode == self.root and self.activeLength > 0:  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",0 days 00:13:29.388000,49,29,93,0 days 00:00:42.955000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part represented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive = False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""Lists edges in the suffix tree""""""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index,
                                                    edge.dest_node_index,
                                                    self.nodes[edge.dest_node_index].suffix_node,
                                                    edge.first_char_index,
                                                    edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                    if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                        break  # prefix is already in tree
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    break  # prefix is already in tree
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node)
        e = Edge(edge.first_char_index, 
                 edge.first_char_index + suffix.length, 
                 suffix.source_node_index, 
                 len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde]:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
18,-2175591245305111728,"[4, 3, 2, 3, 2, 2, 3, 3, 2, 1, 1, 3, 4, 1, 3, 2, 3, 1, 1, 4]","[5, 1, 6, 2]",2022-10-11 20:44:58.447000+03:00,0 days 00:02:10.033000,39,"res = 0.0
for i in range(100):
    res += ((x + 2 * y) ** m) / (n ** (0.5 * n))
    ",0 days 00:01:07.925000,43.34433333333333,6,3,0.6536802196365539,0.6459898641114179,0 days 00:01:56.961000,69,"def f(x, y, m, n):
    product = 1.0
    for i in range(101):
        term1 = math.sqrt(18 * m)
        term2 = 0.5 * y ** m
        product *= term1 - term2
    return x - product",0 days 00:00:16.804000,16.708714285714287,20,7,1.5817238224707382,1.538974529971529,0 days 00:28:26.568000,35,22,3101,0 days 00:01:17.329000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator import attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    """"""
    for leaf nodes, it stores the index of suffix for the path from root to leaf
    """"""
    def __init__(self, leaf):
        # self.__identifier__ = identifier
        self.children = {}
        self.leaf = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(sell, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
        if name == 'end' and self.leaf:
            return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    """"""
    initiate the tree.
    
    activeEdge is represeted as input string character index (not the character itself).
    remainingSuffixCount tells how many suffixes yet to be added in tree.
    size equal to length of input string.
    """"""
    def __init__(self, data):
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        
        self.activeEdge = -1
        self.activeLength = 0

        self.remainingSuffixCount = 0
        self.rootEnd = Nane
        self.splitEnd = None
        self.size = -1
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    """"""
    Walk down from current node.

    activePoint change for walk down (APCFWD) using Skip/Count trick  (rick 1).
    If activeLength is greater than current edge length, set next internal node as activeNode and adjust activeEdge and activeLength accordingly to represent same activePoint.
    """"""
    def walk_down(self, current_node):
        length = sel.edge_length(current_node)

        if self.activeLength >= length:
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    """"""
    For root node, suffixLink will be set to NULL.
    For internal nodes, suffixLink will be set to root.
    by default in current extension and may change in next extension.

    suffixIndex will be set to -1 by default and actual suffix index will be set later for leaves at the end of all phases.
    """"""
    def new_node(self, start, end=None, leaf=False):
        node = Node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        node.suffixIndex = -1
        return node

    """"""
    Extension Rule 1: takes care of extending all leaves created so far in the tree.
    Increment remainingSuffixCount indicating that a new suffix added to the list of suffixes yet to be added in tree.
    Set lastNewNode to None while starting a new phase, indicating there is no internal node waiting for it's suffix link to reset in current phase.

    Extension Rule 2 (a new leaf edge gets created):
    A new leaf edge is created starting from an existng node (the current activeNode), and if there is any internal node waiting for it's suffix link get reset, point the suffix link from that last internal node to current activeNode.
    Then set lastNewNode to None indicating no more node waiting for suffix link reset.

    Extension Rule 3 (current character being processed is already on the edge):
    If a newly created node waiting for it's suffix link to be set, then set suffix link of that waiting node to current active node.
    """"""
    def extend_suffix_tree(self, pos):
        global leafEnd
        leafEnd = pos
        self.remainingSuffixCount += 1
        elf.lastNewNode = None

        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if self.activeLength == 0:
                self.activeEdge = pos  # APCFALZ

                #  Check if there is no outgoing edge starting with activeEdge from activeNode
                if self.activeNode.children.get(self._string[self.activeEdge]) is None:
                    self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)

                if self.lastNewNode is not None:
                    self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
            else:  #  There is an outgoing edge starting with activeEdge from activeNode
                #  Get the next node at the end of edge starting with activeEdge
                _next = self.activeNode.children.get(self._string[self.activeEdge])
                if self.walk_down(_next):  # Do walkdown
                    continue  # Start from _next node (the new activeNode)

                if self.._string[_next.start + self.activeLength] == self._string[pos]:
                    if (self.lastNewNode is note None) and (self.activeNode != self.root):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    break #  Stop all further processing in this phase and move on to _next phase

                """"""
                We will be here when activePoint is in middle of the edge being traversed and current character being processed is not on the edge (we fall off the tree). In this case, we add a new internal node and a new leaf edge going out of that new node. This is Extension Rule 2, where a new leaf edge and a new internal node get created.
                """"""
                self.splitEnd = _next.start ++ self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.childrenself._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next

                """"""
                We got a new internal node here. If there is any internal node created in last extensions of same phase which is still waiting for it's suffix link reset, do it now.
                """"""

                if self.lastNewNode is not None:
                    # suffixLink of lastNewNode points to current newly created internal node
                    self.lastNewNode.suffixLink = split

                """"""
                Make the current newly created internal node waiting for it's suffix link reset (which is pointing to self.root at present).
                We come across any other internal node (existing or newly created) in next extension of same phase, when a new leaf edge gets added (i.e. when Extension Rule 2 applies is any of the next extension of same phase) at that point, suffixLink of this node will point to that internal node.
                """"""

                self.lastNewNode = split

                """"""
                One suffix got added in tree, decrement the count of
                   suffixes yet to be added.
                """"""
                self.remainingSuffixCount -= 1

            if (self.activeNode == self.root) and (self.activeLength > 0):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif self.activeNode != self.root:  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",0 days 00:15:47.475000,45,25,949,0 days 00:00:35.624000,"# https://github.com/kvh/Python-Suffix-Tree

""""""
    A node in the puffix tree.

    suffix_node
        index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
""""""
class Node(object):
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

""""""
An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge.
    last_char_index
        index of end of string part represented by this edge.
    source_node_index
        index of source node of edge.
    dest_node_index
        index of destination node of edge.
""""""
class Edge(object):
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)' % \
               (self.source_node_index, self.dest_node_index ,self.first_char_index, self.last_char_index)

""""""
Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts.
    first_char_index
        index of start of suffix in string.
    last_char_index
        index of end of suffix in string.
""""""
class Suffix(object):
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    """"""
    A suffix is explicit if it ends on a node.
    first_char_index is set greater than last_char_index to indicate this.
    """"""
    def explicit(self):
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index

""""""
A suffix tree for string matching. 
Uses Ukkonen's algorithm for construction.
""""""
class SuffixTree(object):
    """"""
    string
        the string for which to construct a suffix tree
    """"""
    def __init__(self, string, case_insensitive=False)
        self.string = string
        self.case_insensitive = case_insensitive
        
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)

        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    """"""
    Lists edges in the suffix tre
    """"""
    def __repr__(self):
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key= lambda x: x.source_node_index)

        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" %
                    (
                        edge.source_node_index,
                        edge.dest_node_index,
                        self.nodes[edge.dest_node_index].suffix_node,
                        edge.first_char_index,
                        edge.last_char_index
                    )
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + '\n'
        return s

    """"""
    The core construction method.
    """"""
    def _add_prefix(self, last_char_index):
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    break  # prefix is already in tree
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    break  # prefix is already in tree
                parent_node = self._split_edge(e, self.active)

            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)

        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node

        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(
            edge.first_char_index,
            edge.first_char_index + suffix.length,
            suffix.source_node_index,
            len(self.nodes) - 1
        )

        self._remove_edge(edge)
        self._insert_edge(e)

        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index

        self._insert_edge(edge)
        return e.dest_node_index

    """"""
    This canonizes the suffix, walking along its suffix string until it is explicit or there are no more matched nodes.
    """"""
    def _cananize_suffix(self, suffix):
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
            suffix.source_node_index = e.dest_node_index
            self._canonize_suffix(suffix)

    # Public methods

    """"""
    Returns the index of substring in string or -1 if it is not found.
    """"""
    def find_substring(self, substring):
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()

        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((cur_node, substring[i]))
            if not edge:
                return -1

            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_index:edge.first_char_index + ln]:
                return -1

            i += edge.length + 1
            curr_node = edge.dest_node_index

        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
19,-1676633432969270101,"[3, 2, 2, 1, 2, 2, 1, 1, 1, 1, 2, 1, 3, 1, 1, 1, 2, 1, 1, 3]","[4, 0, 3, 7]",2022-10-11 19:27:40.534000+02:00,0 days 00:03:15.346000,72,"x = int(input())
y = int(input())
m = int(input())

sum = 0
for n in range(0, 101):
    sum += ((x + 2 * y) ** m) / n ** (0.5 * n)
print(su)    ",0 days 00:01:03.210000,24.41825,7,8,0.7576300512936021,0.7371535634208021,0 days 00:02:28.945000,54,"x = int(input())
y = int(input())
m = int(input())

prod = 1
for n in range(0, 101):
    prod *= (18 * m) ** 0.5 - 0.5 * (y ** m)
f = x - prod
print(",0 days 00:00:42.043000,16.549444444444443,13,9,1.1279331296787405,1.0003692638222164,0 days 00:18:34.773000,21,15,185,0 days 00:03:01.258000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator importt attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __inid__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path  from root to leaf""""""
        self.leaf x = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
        if name == 'end':
            if self.leaf:
                return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""initiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represeted as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = None
        self.splitEnd = None
        self.size = -1  # Lengts of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (rick 1). If activeLength is greater
        than current edge length, set next  internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = sel.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end = None, leaf = False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in  current extension and may change in
        next extension""""""
        node = Node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = [-1]
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far n tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in ree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         it's suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos  # APCFALZ
            #  There is no outgoing edge starting with
            #  activeEdge from activeNode
                if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                # Extension Rule 2 (A new leaf edge gets created)
                    self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                """"""A new leaf edge is created in above line starting
                 from  an existng node (the current activeNode), and
                 if there is any internal \ode waiting for it's suffix
                 link get reset, point the suffix link from that last
                 internal node to current activeNode. Then set lastNewNode
                 to None indicating no more noe waiting for suffix link
                 reset.""""""
                if (self.lastNewNode is not None):
                    self.lastNewNode.suffixLink = self.activeNode
                    self.lastNewNode = None
            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.ctiveEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if (self.._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent. active node
                    if((self.lastNewNode is note None) and (self.activeNode != self.root)):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break
                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not  on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                internal node get created""""""
                self.splitEnd = _next.start ++ self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.childrenself._string[pos] = self.new_node(pos, leaf = True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for it's suffix link
                  reset, do it now.""""""
                if (self.lastNewNode iss not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                  for it's suffix link reset (which is pointing to self.root
                  at present). Id we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies is any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node.""""""
                self.lastNewNode = splid
            """"""One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
                    self.remainingSuffixCount -= 1
            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink",0 days 00:08:23.044000,17,14,59,0 days 00:00:25.707000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __inid__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive = False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                    ,edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
20,1754418283567680347,"[2, 1, 1, 2, 2, 4, 2, 2, 2, 3, 2, 1, 2, 3, 2, 1, 2, 1, 1, 1]","[1, 5, 2, 6]",2022-08-09 17:30:46.221000+03:00,0 days 00:03:22.861000,72,"def f(x, y, m, n):
    m = (x + 2y) ** m
    den = np.sum(np.power(np.arange(1, 101), -0.5 * np.arange(1, 101)))
    return m * de
    ",0 days 00:00:09.474000,50.71525,34,4,0.9070250072709886,0.6654803042477362,0 days 00:02:53.456000,71,"def f(x, y, m, n):
    t1 = (18 * m) ** 0.5 - 0.5 * y ** m
   
    return x - t1 ** 101",0 days 00:00:04.612000,43.364,47,4,1.020431694493128,0.501568121022046,0 days 00:16:00.122000,52,30,152,0 days 00:00:34.413000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator import attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __init__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path  from root to leaf
        self.leaf = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
        if name == 'end':
            if self.leaf:
                return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""initiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represeted as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = None
        self.splitEnd = None
        self.size = -1  # Lengts of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (rick 1). If activeLength is greater
        than current edge length, set next  internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = self.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in  current extension and may change in
        next extension""""""
        node = Node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far in tree""""""
        
        leafEnd = pos
        
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in tree""""""

        self.remainingSuffixCount += 1

        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         it's suffix link reset in current phase""""""

        self.lastNewNode = None

        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos  # APCFALZ
                #  There is no outgoing edge starting with
                #  activeEdge from activeNode

                if self.activeNode.children.get(self._string[self.activeEdge]) is None:
                    # Extension Rule 2 (A new leaf edge gets created)
                    self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)

                """"""A new leaf edge is created in above line starting
                 from  an existng node (the current activeNode), and
                 if there is any internal Node waiting for it's suffix
                 link get reset, point the suffix link from that last
                 internal node to current activeNode. Then set lastNewNode
                 to None indicating no more noe waiting for suffix link
                 reset""""""

                if self.lastNewNode is not None:
                    self.lastNewNode.suffixLink = self.activeNode
                    self.lastNewNode = None

            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge

                _next = self.activeNode.children.get(self._string[self.activeEdge])

                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue

                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""

                if self._string[_next.start + self.activeLength] == self._string[pos]:
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent active node
                    if (self.lastNewNode is not None) and (self.activeNode != self.root):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None

                    # APCFER3
                    self.activeLength += 1

                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break

                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not  on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                  internal node get created""""""

                self.splitEnd = _next.start + self.activeLength - 1

                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split

                # New leaf coming out of new internal node
                split.children[self._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next

                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for it's suffix link
                  reset, do it now""""""

                if (self.lastNewNode is not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split

                """"""Make the current newly created internal node waiting
                  for it's suffix link reset (which is pointing to self.root
                  at present). If we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies is any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node""""""

                self.lastNewNode = split

                """"""One suffix got added in tree, decrement the count of
                   suffixes yet to be added""""""
                self.remainingSuffixCount -= 1

            if (self.activeNode == self.root) and (self.activeLength > 0):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",0 days 00:13:03.767000,62,28,89,0 days 00:00:11.415000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

        suffix_node
            the index of a node with a matching suffix, representing a suffix link.
            -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
        first_char_index
            index of start of string part represented by this edge
        last_char_index
            index of end of string part represented by this edge
        source_node_index
            index of source node of edge
        dest_node_index
            index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
        source_node_index
            index of node where this suffix starts
        first_char_index
            index of start of suffix in string
        last_char_index
            index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
            is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
        for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
            string
                the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
            Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                    ,edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index: top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
            The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, 
                 suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
            is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
            is not found.
        """"""
        if not substring:
            return -1
        
        if self.case_insensitive:
            substring = substring.lower()
        
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i: i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
21,27046048615976981,"[2, 2, 1, 3, 3, 2, 3, 1, 3, 4, 2, 4, 1, 1, 2, 1, 4, 4, 3, 3]","[4, 0, 3, 7]",2022-08-11 12:16:39.098000+02:00,0 days 00:02:18.409000,20,"def f(x: int,y: int, m: int, n: int) -> float:
    res = 0
    for _ in range(100):
        res += ((x + 2 * y) ** m) / n ** (0.5 * n
    pass",0 days 00:00:20.656000,27.6818,9,5,0.9464702439870241,1.0259448446271557,0 days 00:02:22.756000,50,"import math

def f(x: int, y: int, m: int, n: int) -> float:
    product = 1
    for _ in range(100):
        product *= math.sqrt(18 * m) - 0.5 * y ** m
    return x -",0 days 00:00:23.734000,20.393714285714285,15,7,1.0857687242567737,1.176833197904116,0 days 00:09:16.509000,52,23,41,0 days 00:01:08.776000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator import attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __init__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path  from root to leaf""""""
        self.leaf = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
            if name == 'end':
                if self.leaf:
                    return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""Initiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represeted as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = None
        self.splitEnd = None
        self.size = -1  # Lengths of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (rick 1). If activeLength is greater
        than current edge length, set next  internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = self.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in  current extension and may change in
        next extension""""""
        node = Node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex -= 1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far n tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in ree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         it's suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos  # APCFALZ
                #  There is no outgoing edge starting with
                #  activeEdge from activeNode
                if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                    # Extension Rule 2 (A new leaf edge gets created)
                    self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                    """"""A new leaf edge is created in above line starting
                     from  an existng node (the current activeNode), and
                     if there is any internal \ode waiting for it's suffix
                     link get reset, point the suffix link from that last
                     internal node to current activeNode. Then set lastNewNode
                     to None indicating no more noe waiting for suffix link
                     reset.""""""
                if (self.lastNewNode is not None):
                    self.lastNewNode.suffixLink = self.activeNode
                    self.lastNewNode = None
            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.activeEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if (self._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent. active node
                    if((self.lastNewNode is not None) and (self.activeNode != self.root)):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break
                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                internal node get created""""""
                self.splitEnd = _next.start + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.children[self._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for it's suffix link
                  reset, do it now.""""""
                if (self.lastNewNode is not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                    """"""Make the current newly created internal node waiting
                      for it's suffix link reset (which is pointing to self.root
                      at present). Id we come across any other internal node
                      (existing or newly created) in next extension of same
                      phase, when a new leaf edge gets added (i.e. when
                      Extension Rule 2 applies is any of the next extension
                      of same phase) at that point, suffixLink of this node
                      will point to that internal node.""""""
                    self.lastNewNode = splid
                    """"""One suffix got added in tree, decrement the count of
                       suffixes yet to be added.""""""
                    self.remainingSuffixCount -= 1
            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink",0 days 00:06:52.399000,34,20,52,0 days 00:00:16.119000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. 
        first_char_index
            is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                   suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
22,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]","[4, 0, 3, 7]",2022-08-30 13:24:26.117000+02:00,0 days 00:04:09.299000,23,"def f(x, y, m, n):
    sum = 0
    for i in range(101):
        sum += ((x + 2y) ** m) / (n ** (0.5 * i))
    ",0 days 00:00:23.756000,62.32475,5,4,0.38909101119539186,0.44123722919065056,0 days 00:03:27.967000,43,"from math import sqrt 

def f(x, y, m, n):
    product = 1
    for i in range(101):
        product *= sqrt(18 * m) - 0.5 * (y ** m)
    return x - pr",0 days 00:01:02.753000,29.70957142857143,15,7,0.7597359196410969,0.7212682781402818,0 days 00:11:13.575000,28,21,32,0 days 00:01:13.977000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator import attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __init__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path  from root to leaf""""""
        self.leaf = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
        if name == 'end':
            if self.leaf:
                return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""nitiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represeted as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = Nane
        self.splitEnd = None
        self.size = -1  # Lengts of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (rick 1). If activeLength is greater
        than current edge length, set next  internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = self.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in  current extension and may change in
        next extension""""""
        node = Node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far n tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in ree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         it's suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos  # APCFALZ
                #  There is no outgoing edge starting with
                #  activeEdge from activeNode
                if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                    # Extension Rule 2 (A new leaf edge gets created)
                    self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                """"""A new leaf edge is created in above line starting
                 from  an existng node (the current activeNode), and
                 if there is any internal \ode waiting for it's suffix
                 link get reset, point the suffix link from that last
                 internal node to current activeNode. Then set lastNewNode
                 to None indicating no more noe waiting for suffix link
                 reset.""""""
                if (self.lastNewNode is not None):
                    self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.activeEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if (self._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent. active node
                    if ((self.lastNewNode is not None) and (self.activeNode != self.root)):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break
                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not  on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                internal node get created""""""
                self.splitEnd = _next.start + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.children[self._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for it's suffix link
                  reset, do it now.""""""
                if (self.lastNewNode is not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                  for it's suffix link reset (which is pointing to self.root
                  at present). Id we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies is any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node.""""""
                self.lastNewNode = spli
            """"""One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
                    self.remainingSuffixCount -= 1
            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink",0 days 00:13:49.477000,44,26,65,0 days 00:00:55.659000,"# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
23,6892333249046467736,"[2, 1, 1, 1, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 2, 2, 3, 2, 2, 3]","[5, 1, 6, 2]",2022-08-26 14:08:22.824000+03:00,0 days 00:05:57.555000,87,"import numpy as np
def f(x, y, m, n):
    n = np.arange(0, 100)
    return (x + 2 * y) ** m / np.sum(1 / n ** (n / 3))
",0 days 00:00:33.097000,89.38875,24,4,0.4111255611024877,0.3328159304162996,0 days 00:03:37.784000,43,"import numpy as np

def f(x, y, m, n):
    return x - (np.sqrt(18 * m) - 0.5 * y ** m)** 10

",0 days 00:00:19.140000,54.446,20,4,0.5831466039745803,0.42702861550894466,0 days 00:26:34.708000,53,27,322,0 days 00:01:57.481000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator import attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __init__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path from root to leaf""""""
        self.leaf_x = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
        if name == 'end':
            if self.leaf:
                return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""Initiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represented as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = None
        self.splitEnd = None
        self.size = -1  # Lengts of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (Trick 1). If activeLength is greater
        than current edge length, set next internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = self.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in  current extension and may change in
        next extension""""""
        node = node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far in tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in tree""""""
        self.remainingSuffixCount += 1
        """"""Set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         its suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos  # APCFALZ
                #  There is no outgoing edge starting with
                #  activeEdge from activeNode
                if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                    # Extension Rule 2 (A new leaf edge gets created)
                    self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                    """"""A new leaf edge is created in above line starting
                     from  an existng node (the current activeNode), and
                     if there is any internal \ode waiting for it's suffix
                     link get reset, point the suffix link from that last
                     internal node to current activeNode. Then set lastNewNode
                     to None indicating no more noe waiting for suffix link
                     reset.""""""
                if (self.lastNewNode is not None):
                    self.lastNewNode.suffixLink = self.activeNode
                    self.lastNewNode = None
            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.activeEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if (self._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for its
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent active node
                    if ((self.lastNewNode is not None) and (self.activeNode != self.root)):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break
                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not  on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                internal node get created""""""
                self.splitEnd = _next.start + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.children[self._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for its suffix link
                  reset, do it now.""""""
                if (self.lastNewNode is not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                  for it's suffix link reset (which is pointing to self.root
                  at present). Id we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies is any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node.""""""
                self.lastNewNode = split
            """"""One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
                    self.remainingSuffixCount -= 1
            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",0 days 00:17:37.316000,38,26,114,0 days 00:00:35.932000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part represented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index, 
                                         self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False):
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                    ,edge.first_char_index
                    ,edge.last_char_index)

            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node)
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_index:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
24,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]","[0, 4, 7, 3]",2022-09-02 13:06:54.320000+02:00,0 days 00:06:05.729000,219,"def f(x, y, m, n):
    indexes = [i for i in range(0, 100)]
    top = (x + 2 * y) ** m
    seq = [1 / (n ** (0.5 * n)) for n in indexes]
    # result = reduce(seq, 0, lambda t1, t2: t1 + t2)
    result = 0
    for element in seq:
        result += element
    return top result",0 days 00:00:11.924000,40.63655555555555,53,9,0.9159787711666288,0.7573914018303171,0 days 00:07:06.293000,189,"def f(x, y, m, n):
    # I do not remember the ""pythonic"" ways ;^)
    thing = 3 * ((2 * m) ** 0.5)
    anotherThing = 0.5 * (y ** m)
    return x - (thing - anotherThing) ** 1",0 days 00:00:24.558000,85.2586,92,5,0.8022651087397635,0.4128615764274806,0 days 00:17:45.064000,58,26,137,0 days 00:00:42.201000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator import attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-Tree's node.""""""

    def __init__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        """"""
        for leaf nodes, it stores the index of suffix for
        the path  from root to leaf
        """"""
        self.leaf_x = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)
    
    def __ne__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)
    
    def __getattribute__(self, name):
        if name == 'end':
            if self.leaf:
                return leafEnd # What is leafEnd??? Is it self.end?
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""Initiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""
        activeEdge is represeted as input string character
        index (not the character itself)
        """"""
        self.activeEdge = -1
        self.activeLength = 0
        # Why """""" and # are mixed???
        # remainingSuffixCount tells how many suffixes yet to
        # be added in the tree
        self.remainingSuffixCount = 0
        self.rootEnd = None
        self.splitEnd = None
        self.size = -1  # Lengts of the input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""
        Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (rick 1). If activeLength is greater
        than current edge length, set next internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = self.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""
        For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in  current extension and may change in
        next extension
        """"""
        node = Node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""
        suffixIndex will be set to -1 by default and
        actual suffix index will be set later for leaves
        at the end of all phases
        """"""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        # I think that such comments should have """""" on separate lines, but am too tired to fix that everywhere
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far in the tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in ree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         its suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if (self.activeLength == 0):  # It's better to write !self.activeLength
                self.activeEdge = pos  # APCFALZ
                #  There is no outgoing edge starting with
                #  activeEdge from activeNode
                if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                    # Extension Rule 2 (A new leaf edge gets created)
                    self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                    """"""A new leaf edge is created in above line starting
                     from  an existng node (the current activeNode), and
                     if there is any internal \ode waiting for it's suffix
                     link get reset, point the suffix link from that last
                     internal node to current activeNode. Then set lastNewNode
                     to None indicating no more noe waiting for suffix link
                     reset.""""""
                if (self.lastNewNode is not None):
                    self.lastNewNode.suffixLink = self.activeNode
                    self.lastNewNode = None
            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.activeEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if (self._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent. active node
                    if ((self.lastNewNode is not None) and (self.activeNode != self.root)):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break
                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not  on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                internal node get created""""""
                self.splitEnd = _next.start + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.children[self._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for it's suffix link
                  reset, do it now.""""""
                if (self.lastNewNode is not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                  for it's suffix link reset (which is pointing to self.root
                  at present). Id we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies is any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node.""""""
                self.lastNewNode = split
            """"""One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
                    self.remainingSuffixCount -= 1
            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink",0 days 00:16:47.052000,51,25,165,0 days 00:00:36.011000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A very meaningful name, thank you!
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
25,-4741187018347557470,"[4, 2, 2, 3, 2, 1, 2, 2, 2, 3, 1, 1, 3, 1, 3, 2, 1, 1, 1, 1]","[1, 5, 2, 6]",2022-09-16 12:36:37.099000+02:00,0 days 00:02:43.701000,34,"def f(x, y, m):
    res = 0
    for n in range(101):
        res += ((x + 2 * y) ** m) / n ** (0.5 * n)
    return res
f(10, 1, )",0 days 00:00:42.103000,27.2835,17,6,0.8918699335984509,0.7880220646178093,0 days 00:01:40.533000,21,"def f(x, y, m):
    res = 1
    for n in range(101):
        res *= (18 * m) ** 0.5 - 0.5 * y ** m
    return x - res
f(10, 1,)",0 days 00:00:20.544000,16.7555,13,6,1.2931077357683547,1.2632667880198543,0 days 00:21:28.761000,46,30,88,0 days 00:01:05.514000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator import attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __init__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path  from root to leaf""""""
        self.leaf = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
        if name == 'end':
            if self.leaf:
                return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""Initiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represeted as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = None
        self.splitEnd = None
        self.size = -1  # Lengts of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (rick 1). If activeLength is greater
        than current edge length, set next  internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = self.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in  current extension and may change in
        next extension""""""
        node = Node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far in tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in tree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         it's suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos  # APCFALZ
            #  There is no outgoing edge starting with
            #  activeEdge from activeNode
            if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                # Extension Rule 2 (A new leaf edge gets created)
                self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                """"""A new leaf edge is created in above line starting
                 from  an existing node (the current activeNode), and
                 if there is any internal node waiting for its suffix
                 link get reset, point the suffix link from that last
                 internal node to current activeNode. Then set lastNewNode
                 to None indicating no more node waiting for suffix link
                 reset.""""""
                if (self.lastNewNode is not None):
                    self.lastNewNode.suffixLink = self.activeNode
                    self.lastNewNode = None
            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.activeEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if (self._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for its
                    # suffix link to be set, then set suffix link
                    # of that waiting node to current active node
                    if((self.lastNewNode is not None) and (self.activeNode != self.root)):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to next phase""""""
                    break
                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                  internal node get created""""""
                self.splitEnd = _next.start + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.children[self._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for its suffix link
                  reset, do it now.""""""
                if (self.lastNewNode is not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                  for its suffix link reset (which is pointing to self.root
                  at present). If we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies is any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node.""""""
                self.lastNewNode = split
            """"""One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
                self.remainingSuffixCount -= 1
            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",0 days 00:24:57.809000,45,30,92,0 days 00:00:15.886000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part represented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return ""Edge(%d, %d, %d, %d)""%(self.source_node_index, self.dest_node_index, 
                                       self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index, 
                                                edge.dest_node_index, 
                                                self.nodes[edge.dest_node_index].suffix_node, 
                                                edge.first_char_index, 
                                                edge.last_char_index)

            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+ 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node)
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, 
                 suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
26,-3186961919085993818,"[2, 4, 3, 3, 2, 2, 1, 2, 3, 3, 1, 1, 2, 1, 4, 2, 3, 2, 1, 1]","[4, 0, 3, 7]",2022-07-26 12:35:09.705000+02:00,0 days 00:05:45.385000,55,"def f(x, y, m, n):
    sum = 0
    for n in range(0, 100):
        numerator = ((x + 2 * y) ** m)
        denominator = n ** (0.5 * n) if n > 0 else 1
        sum += numerator / denominator
    return s
",0 days 00:00:32.067000,49.340714285714284,13,7,0.4835183925184939,0.5877499022829596,0 days 00:05:09.588000,51,"import math

def f(x, y, m, n):
    product = 1
    for n in range(0, 100):
        p = math.sqrt(18 * m) - 0.5 * (y ** m)
        product *= p
    return x - pr",0 days 00:00:53.793000,38.6985,8,8,0.42960321459488093,0.5200459966148558,0 days 00:19:11.092000,38,25,270,0 days 00:01:10.971000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator import attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __init__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path  from root to leaf
        self.leaf = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
        if name == 'end':
            if self.leaf:
                return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""Initiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represented as input string character
          index (not the character itself)""""""
            self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = None
        self.splitEnd = None
        self.size = -1  # Lengts of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from the current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (rick 1). If activeLength is greater
        than the current edge length, set the next internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = self.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in the current extension and may change in the
        next extension""""""
        node = Node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far n tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in ree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         it's suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos  # APCFALZ
            #  There is no outgoing edge starting with
            #  activeEdge from activeNode
            if self.activeNode.children.get(self._string[self.activeEdge]) is None:
                # Extension Rule 2 (A new leaf edge gets created)
                self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                """"""A new leaf edge is created in above line starting
                 from  an existng node (the current activeNode), and
                 if there is any internal \ode waiting for it's suffix
                 link get reset, point the suffix link from that last
                 internal node to current activeNode. Then set lastNewNode
                 to None indicating no more noe waiting for suffix link
                 reset.""""""
                if (self.lastNewNode is not None):
                    self.lastNewNode.suffixLink = self.activeNode
                    self.lastNewNode = None
            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.activeEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if (self.._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent. active node
                    if (self.lastNewNode is not None) and (self.activeNode != self.root):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break
                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not  on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                 internal node get created""""""
                self.splitEnd = _next.start + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.children[self._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for it's suffix link
                  reset, do it now.""""""
                if (self.lastNewNode is not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                  for it's suffix link reset (which is pointing to self.root
                  at present). If we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies is any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node.""""""
                self.lastNewNode = split
            """"""One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
            self.remainingSuffixCount -= 1
            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink",0 days 00:23:07.805000,56,27,131,0 days 00:00:54.782000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part represented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm for construction.""""""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""Lists edges in the suffix tree""""""
        cur_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (
                edge.source_node_index,
                edge.dest_node_index,
                self.nodes[edge.dest_node_index].suffix_node,
                edge.first_char_index,
                edge.last_char_index
            )

            top = min(cur_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[(self.active.source_node_index, self.string[self.active.first_char_index])]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[(suffix.source_node_index, self.string[suffix.first_char_index])]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it is not found.""""""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        cur_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((cur_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_index:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            cur_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
27,-1017914840709559411,"[3, 2, 2, 4, 2, 2, 2, 3, 2, 1, 2, 2, 3, 2, 2, 3, 2, 1, 2, 3]","[4, 0, 3, 7]",2022-10-11 19:23:37.662000+02:00,0 days 00:10:34.652000,45,"def f(x, y, m, n):
    result = 0
    for i in range(101):
        result += (x + 2 * y) ** m / (n ** (0.5 * n))
    return result",0 days 00:00:28.019000,126.9304,23,5,0.241076999678564,0.2048366663935511,0 days 00:02:19.244000,58,"def f(x, y, m, n):
    result = 1
    for i in range(101):
        result *= sqrt(18 * m) - 0.5 * (y ** m)
    return x - result",0 days 00:01:06.339000,27.8488,28,5,1.0628824222228606,0.9192496624630145,0 days 00:19:53.318000,26,2,77,0 days 00:01:27.393000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator importt attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __init__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path  from root to leaf""""""
        self.leaf x= leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None


    def __eq__(sell, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)


    def __ne__(self, noda):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)


    def __getattribute__(self, name):
            if name == 'end':
            if self.leaf:
                return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""nitiate the tree.""""""
        self._string = data
        self.previousNode = None
        self.activeNode = None
        """"""activeEdge is represeted as input string character
          index (not the character itself)""""""
            self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = Nane
        self.splitEnd = None
        self.size = -1  # Lengts of input string
        self.root = None


    def edgeLength(self, node):
        return node.end - node.start + 1


    def walkDown(self, currentNode):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (rick 1). If activeLength is greater
        than current edge length, set next  internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = sel.edgeLength(currentNode)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = currentNode
        return True
        return False


    def newnode(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in  current extension and may change in
        next extension""""""
        node = ode(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = nd
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -[1
        return node


    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far n tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in ree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         it's suffix link reset in current phase""""""
        elf.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while self.remainingSuffixCount > 0:
            if self.activeLength == 0:
                self.activeEdge = pos  # APCFALZ
            #  There is no outgoing edge starting with
            #  activeEdge from activeNode
                if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                # Extension Rule 2 (A new leaf edge gets created)
                self.activeNode.children[self._string[self.activeEdge]] = self.newNode(pos, leaf=True)
                """"""A new leaf edge is created in above line starting
                 from  an existng node (the current activeNode), and
                 if there is any internal \ode waiting for it's suffix
                 link get reset, point the suffix link from that last
                 internal node to current activeNode. Then set lastNewNode
                 to None indicating no more noe waiting for suffix link
                 reset.""""""
                if self.lastNewNode is not None:
                    self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.ctiveEdge])
                if self.walkDown(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if self.._string[_next.start + self.activeLength] == self._string[pos]:
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent. active node
                    if (self.lastNewNode is note None) and (self.activeNode != self.root):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    breakk
                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not  on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                internal node get created""""""
                self.splitEnd = _next.start ++ self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.childrenself._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for it's suffix link
                  reset, do it now.""""""
                if self.lastNewNode iss not None:
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                  for it's suffix link reset (which is pointing to self.root
                  at present). Id we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies is any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node.""""""
                self.lastNewNode = splid
            """"""One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
                    self.remainingSuffixCount -= 1
            if self.activeNode == self.root and self.activeLength > 0:  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif self.activeNode != self.root:  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink",0 days 00:08:30.336000,21,6,278,0 days 00:00:43.322000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, firstCharIndex, lastCharIndex, sourceNodeIndex, destNodeIndex):
        elf.firstCharIndex = firstCharIndex
        self.lastCharIndex = lastCharIndex
        self.sourceNodeIndex = sourceNodeIndex
        self.destNodeIndex = destNodeIndex

    @property
        def length(self):
        return self.lastCharIndex - self.firstCharIndex

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index


    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index


    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index


    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)


    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s


    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)


    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge


    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))


    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index


    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)


    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curren_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            length = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + length
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
28,5133665405822191492,"[3, 1, 4, 3, 4, 3, 2, 3, 3, 4, 3, 4, 4, 4, 4, 3, 4, 4, 4, 4]","[0, 4, 7, 3]",2022-08-19 11:30:54.540000+03:00,0 days 00:02:08.868000,78,"def f(x, y, m, n):
    return sum([((x + 2*y)**/(n**(0.5*i)) for i in range(100))])
",0 days 00:00:12.366000,64.434,18,2,0.8768662507371885,0.6518297793090605,0 days 00:02:51.357000,133,"import math

def f(x, y, m, n):
    return x - math.prod([math.sqrt(18*m) - 0.5 * y**m for i in range(100)])
    ",0 days 00:00:06.148000,42.83925,28,4,1.0737816371668505,0.6594419836948593,0 days 00:14:23.688000,49,21,287,0 days 00:00:33.559000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator import attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __init__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path  from root to leaf""""""
        self.leaf = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(sell, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __neq__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
        if name == 'end':
                if self.leaf:
                    return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""nitiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represeted as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = None
        self.splitEnd = None
        self.size = -1  # Lengts of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick (rick 1). If activeLength is greater
        than current edge length, set next internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = sel.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to None
        For internal nodes, suffixLink will be set to root
        by default in  current extension and may change in
        next extension""""""
        node = Node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = nd
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far in tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added in tree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         it's suffix link reset in current phase""""""
        elf.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos
                #  There is no outgoing edge starting with
                #  activeEdge from activeNode
                if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                    # Extension Rule 2 (A new leaf edge gets created)
                    self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                    """"""A new leaf edge is created in above line starting
                     from  an existng node (the current activeNode), and
                     if there is any internal node waiting for it's suffix
                     link get reset, point the suffix link from that last
                     internal node to current activeNode. Then set lastNewNode
                     to None indicating no more noe waiting for suffix link
                     reset.""""""
                    if (self.lastNewNode is not None):
                        self.lastNewNode.suffixLink = self.activeNode
                            self.lastNewNode = None

            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.ctiveEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if (self._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to active node
                    if((self.lastNewNode is note None) and (self.activeNode != self.root)):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break
                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not  on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                internal node get created""""""
                self.splitEnd = _next.start + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.children[self._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for it's suffix link
                  reset, do it now.""""""
                if (self.lastNewNode is not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                  for it's suffix link reset (which is pointing to self.root
                  at present). Id we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies is any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node.""""""
                self.lastNewNode = split
            """"""One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
            self.remainingSuffixCount -= 1
            if ((self.activeNode == self.root) and (self.activeLength > 0)):
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):
                self.activeNode = self.activeNode.suffixLink

",0 days 00:12:21.347000,38,25,77,0 days 00:01:00.068000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part represented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index, 
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                    ,edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node)
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index,
                 len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
29,4752725055756242759,"[4, 3, 3, 3, 1, 2, 1, 1, 1, 2, 2, 2, 3, 1, 2, 1, 2, 2, 3, 2]","[0, 4, 7, 3]",2022-07-19 13:12:03.652000+03:00,0 days 00:02:02.007000,82,"import numpy as np
def single_f(x, y, n, m):
    return (x + 2 * y) ** m / n ** (0.5 * n) 

def f(x, y, m, n):
    return sum( single_f(x, y, m, n) for n in range(101))",0 days 00:00:19.386000,20.334500000000002,5,6,1.3933626759120379,1.3769701738424844,0 days 00:01:57.209000,61,"import numpy as np
def single_f(y, m):
    return np.sqrt(18 * m) - 0.5 * y ** m

def f(x, y, m, n):
    return x - single_f(y, m) ** 101",0 days 00:00:07.301000,19.534833333333335,20,6,1.5101229427774316,1.1688522212458088,0 days 00:14:37.691000,97,25,3085,0 days 00:00:39.420000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read ??? 
from operator import attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __init__(self, leaf):
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path  from root to leaf
        self.leaf = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(sell, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, noda):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
            if name == 'end':
            if self.leaf:
                return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""nitiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""
        activeEdge is represented as input string character
        index (not the character itself)
        """"""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = Nane
        self.splitEnd = None
        self.size = -1  # Lengts of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""
        Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (Trick 1). If activeLength is greater
        than current edge length, set next internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = self.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
        return True # TODO: ???
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""
        For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in current extension and may change in
        next extension
        """"""
        node = Node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""
        suffixIndex will be set to -1 by default and
        actual suffix index will be set later for leaves
        at the end of all phases
        """"""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""
        Extension Rule 1, this takes care of extending all
        leaves created so far in the tree
        """"""
        leafEnd = pos
        """"""
        Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in the tree
        """"""
        self.remainingSuffixCount += 1
        """"""
        set lastNewNode to None while starting a new phase,
        indicating there is no internal node waiting for
        its suffix link reset in current phase
        """"""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while self.remainingSuffixCount > 0:
            if self.activeLength == 0:
                self.activeEdge = pos  # APCFALZ
            
            #  There is no outgoing edge starting with
            #  activeEdge from activeNode
            if self.activeNode.children.get(self._string[self.activeEdge]) is None:
                # Extension Rule 2 (A new leaf edge gets created)
                self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                """"""
                A new leaf edge is created in above line starting
                from  an existing node (the current activeNode), and
                if there is any internal node waiting for its suffix
                link to get reset, point the suffix link from that last
                internal node to current activeNode. Then set lastNewNode
                to None indicating no more nodes waiting for suffix link
                reset.
                """"""
                if self.lastNewNode is not None:
                    self.lastNewNode.suffixLink = self.activeNode
                    self.lastNewNode = None

            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.activeEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""
                Extension Rule 3 (current character being processed
                is already on the edge)
                """"""
                if self._string[_next.start + self.activeLength] == self._string[pos]:
                    # If a newly created node waiting for its
                    # suffix link to be set, then set suffix link
                    # of that waiting node to current active node
                    if (self.lastNewNode is not None) and (self.activeNode != self.root):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""
                    STOP all further processing in this phase
                    and move on to next phase
                    """"""
                    break

                """"""
                We will be here when activePoint is in middle of
                the edge being traversed and current character
                being processed is not on the edge (we fall off
                the tree). In this case, we add a new internal node
                and a new leaf edge going out of that new node. This
                is Extension Rule 2, where a new leaf edge and a new
                internal node gets created
                """"""
                self.splitEnd = _next.start + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.children[self._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""
                We got a new internal node here. If there is any
                internal node created in last extensions of same
                phase which is still waiting for its suffix link
                reset, do it now.
                """"""
                if self.lastNewNode is not None:
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""
                Make the current newly created internal node waiting
                for its suffix link reset (which is pointing to self.root
                at present). If we come across any other internal node
                (existing or newly created) in next extension of same
                phase, when a new leaf edge gets added (i.e., when
                Extension Rule 2 applies in any of the next extension
                of same phase) at that point, suffixLink of this node
                will point to that internal node.
                """"""
                self.lastNewNode = split

                """"""
                One suffix got added in tree, decrement the count of
                suffixes yet to be added.
                """"""
                self.remainingSuffixCount -= 1

            if (self.activeNode == self.root) and (self.activeLength > 0):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif self.activeNode != self.root:  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink",0 days 00:11:05.139000,42,26,1022,0 days 00:00:31.899000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index, 
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. 
        first_char_index is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue

            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (
                edge.source_node_index,
                edge.dest_node_index,
                self.nodes[edge.dest_node_index].suffix_node,
                edge.first_char_index,
                edge.last_char_index
            )


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node

            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)

        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node

        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_index:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
30,7431063529679604326,"[4, 3, 4, 4, 4, 2, 3, 2, 1, 1, 4, 4, 4, 2, 4, 4, 4, 4, 1, 2]","[5, 1, 6, 2]",2022-10-11 20:15:40.999000+02:00,0 days 00:03:16.276000,85,"def f(x, y, m, n):
    return sum(map(lambda n: (x + 2 * y) ** m / n ** (0.5 * n), range(10)))",0 days 00:00:18.961000,98.138,7,2,0.5094866412602661,0.47891744278465015,0 days 00:01:59.730000,36,"def f(x, y, m, n):
    p = 1
    for n in range(101):
        p *= (18 * m) ** 0.5 - 0.5 * y ** m
    return x -",0 days 00:00:17.883000,23.946,32,5,1.2778752192432974,0.9354380689885575,0 days 00:16:37.303000,54,27,743,0 days 00:01:14.605000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator importt attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __init__(self, leaf):
        # self.__identifier__ = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path  from root to leaf
        self.leaf.x = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __neq__(self, noda):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
        if name == 'end':
            if self.leaf is not None:
                return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""initiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represented as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = None
        self.splitEnd = None
        self.size = -1  # Lengts of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (trick 1). If activeLength is greater
        than current edge length, set next  internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = self.edge_length(current_node)
        if self.activeLength >= length:
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in  current extension and may change in
        next extension""""""
        node = node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = node
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far in tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in tree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         it's suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while self.remainingSuffixCount > 0:
            if self.activeLength == 0:
                self.activeEdge = pos  # APCFALZ
                #  There is no outgoing edge starting with
                #  activeEdge from activeNode
                if self.activeNode.children.get(self._string[self.activeEdge]) is None:
                    # Extension Rule 2 (A new leaf edge gets created)
                    self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                """"""A new leaf edge is created in above line starting
                 from  an existng node (the current activeNode), and
                 if there is any internal node waiting for it's suffix
                 link get reset, point the suffix link from that last
                 internal node to current activeNode. Then set lastNewNode
                 to None indicating no more node waiting for suffix link
                 reset.""""""
                if self.lastNewNode is not None:
                    self.lastNewNode.suffixLink = self.activeNode
                    self.lastNewNode = None
                #  There is an outgoing edge starting with activeEdge
                #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.activeEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if self._string[_next.start + self.activeLength] == self._string[pos]:
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent.
                    if (self.lastNewNode is node None) and (self.activeNode != self.root):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break
                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not  on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                  internal node get created""""""
                self.splitEnd = _next.start + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.childrenself._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for it's suffix link
                  reset, do it now.""""""
                if self.lastNewNode is not None:
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                  for it's suffix link reset (which is pointing to self.root
                  at present). Id we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies in any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node.""""""
                self.lastNewNode = split
            """"""One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
                    self.remainingSuffixCount -= 1
            if (self.activeNode == self.root) and (self.activeLength > 0):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",0 days 00:09:59.332000,32,21,842,0 days 00:00:39.088000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part represented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                    ,edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
31,-3059015261072660273,"[3, 1, 3, 3, 2, 2, 2, 3, 2, 1, 1, 1, 2, 1, 2, 1, 4, 4, 3, 4]","[1, 5, 2, 6]",2022-07-19 15:37:07.036000+02:00,0 days 00:03:49.101000,69,"def f(x: int, y: int, m: int, n: int) -> int:
    sum_result: int = 0
    
    for n in range(100 + 1):
        sum_result += ((x + 2 * y) ** m) / (n ** (0.5 * n))
        
    return sum_result",0 days 00:00:35.789000,32.72871428571428,13,7,0.6983819363512163,0.8467880978258497,0 days 00:02:59.002000,107,"def f(x: int, y: int, m: int, n: int) -> int:
    dot_product: int = 1
    
    for n in range(100 + 1):
        # dot_product *= (18 * m) ** (0.5) - 0.5 * y ** m
        dot_product *= sqrt(18 * m) ** (0.5) - 0.5 * y ** m
    
    
    return x - dot_product",0 days 00:00:15.277000,19.889111111111113,17,9,1.0782002435726974,1.4469112076960033,0 days 00:13:33.425000,36,20,193,0 days 00:01:49.578000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator import attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __init__(self, leaf):
        self.children = {}
        self.leaf = leaf # for leaf nodes, it stores the index of suffix for the path  from root to leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(sell, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, noda):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
        if name == 'end':
            if self.leaf:
                return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """""" Initiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        self.activeEdge = -1  # activeEdge is represeted as input string character index (not the character itself)
        self.activeLength = 0
        self.remainingSuffixCount = 0  # remainingSuffixCount tells how many suffixes yet to  be added in tree
        self.rootEnd = Nane
        self.splitEnd = None
        self.size = -1  # Lengts of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (trick 1). If activeLength is greater
        than current edge length, set next  internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = self.edge_length(current_node)

        if self.activeLength >= length:
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True

        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in  current extension and may change in
        next extension""""""
        node = Node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far n tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in ree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         it's suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while self.remainingSuffixCount > 0:
            if (self.activeLength == 0):
                self.activeEdge = pos  # APCFALZ
                #  There is no outgoing edge starting with
                #  activeEdge from activeNode
                if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                # Extension Rule 2 (A new leaf edge gets created)
                self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                """"""A new leaf edge is created in above line starting
                 from  an existng node (the current activeNode), and
                 if there is any internal \ode waiting for it's suffix
                 link get reset, point the suffix link from that last
                 internal node to current activeNode. Then set lastNewNode
                 to None indicating no more noe waiting for suffix link
                 reset.""""""
                if (self.lastNewNode is not None):
                    self.lastNewNode.suffixLink = self.activeNode
                    self.lastNewNode = None
        #  There is an outgoing edge starting with activeEdge
        #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.ctiveEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if (self.._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent. active node
                    if ((self.lastNewNode is note None) and (self.activeNode != self.root)):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break
                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not  on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                internal node get created""""""
                self.splitEnd = _next.start + + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.childrenself._string[pos] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for it's suffix link
                  reset, do it now.""""""
                if self.lastNewNode is not None:
                # suffixLink of lastNewNode points to current newly
                # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                  for it's suffix link reset (which is pointing to self.root
                  at present). Id we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies is any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node.""""""
                self.lastNewNode = split
                """"""One suffix got added in tree, decrement the count of
                   suffixes yet to be added.""""""
                self.remainingSuffixCount -= 1
                if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                    self.activeLength -= 1
                    self.activeEdge = pos - self.remainingSuffixCount + 1
                elif (self.activeNode != self.root):  # APCFER2C2
                    self.activeNode = self.activeNode.suffixLink
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",0 days 00:12:56.071000,39,19,141,0 days 00:00:43.200000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index, self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index,
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                    if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                        # prefix is already in tree
                        break
                else:
                    e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                    if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                        # prefix is already in tree
                        break
                    parent_node = self._split_edge(e, self.active)


            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, 
                 suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
32,3606889061502973072,"[4, 4, 3, 4, 2, 3, 3, 2, 1, 2, 3, 3, 4, 1, 2, 3, 3, 2, 4, 2]","[0, 4, 7, 3]",2022-10-11 19:16:48.357000+02:00,0 days 00:02:47.157000,115,"def f(x,y,m,n):
    ans=0
    for i in range(101):
        ans += ((x + 2 * y) ** m)/ (n ** (0.5 * n))
    return a",0 days 00:00:53.698000,33.431400000000004,16,5,0.7178879735817225,0.6879759746824841,0 days 00:02:01.885000,53,"def f(x,y,m,n):
    ans = x
    P = 1
    for i in range(101):
        P*= sqrt(18 *m) - 0.5 * y ** M
    return ans - P",0 days 00:00:10.901000,20.31416666666667,9,6,0.9271034171555154,0.9845346022890429,0 days 00:04:25.017000,8,5,1220,0 days 00:00:54.416000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator importt attrgetter

leafEnd = -1

class Node:
    """"""The Suffix-tree's node.""""""

    def __inid__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path  from root to leaf""""""
        self.leaf x = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(sell, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, noda):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
            if name == 'end':
            if self.leaf:
                return leafEnd
            return super(Node, self).__getattribute__(name)

class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""nitiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represeted as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = Nane
        self.splitEnd = None
        self.size = -1  # Lengts of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (rick 1). If activeLength is greater
        than current edge length, set next  internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.""""""
        
        length = sel.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
        return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in  current extension and may change in
        next extension""""""
        node = ode(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = nd
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far n tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in ree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         it's suffix link reset in current phase""""""
        elf.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos  # APCFALZ
            #  There is no outgoing edge starting with
            #  activeEdge from activeNode
                if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                # Extension Rule 2 (A new leaf edge gets created)
                self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                """"""A new leaf edge is created in above line starting
                 from  an existng node (the current activeNode), and
                 if there is any internal \ode waiting for it's suffix
                 link get reset, point the suffix link from that last
                 internal node to current activeNode. Then set lastNewNode
                 to None indicating no more noe waiting for suffix link
                 reset.""""""
                if (self.lastNewNode is not None):
                    self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.ctiveEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if (self.._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent. active node
                    if((self.lastNewNode is note None) and (self.activeNode != self.root)):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break
                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not  on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                internal node get created""""""
                self.splitEnd = _next.start + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.childrenself._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for it's suffix link
                  reset, do it now.""""""
                if (self.lastNewNode iss not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                  for it's suffix link reset (which is pointing to self.root
                  at present). Id we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies is any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node.""""""
                self.lastNewNode = splid
            """"""One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
                    self.remainingSuffixCount -= 1
            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink",0 days 00:06:05.391000,13,8,469,0 days 00:01:37.315000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __inid__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
    return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key = lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                    ,edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index: (top + 1)] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                   suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
33,3004833227449367799,"[4, 1, 2, 3, 2, 1, 1, 2, 1, 1, 1, 1, 3, 2, 4, 3, 2, 3, 3, 2]","[5, 1, 6, 2]",2022-09-16 14:10:18.932000+02:00,0 days 00:04:35.847000,26,"def f(x, y, m,):
    n = 0
    result = 0
    for n in range(101):
        result += ((x + 2 * y) ** m) / (n ** (0.5 * n))
    return result",0 days 00:00:32.735000,45.9745,11,6,0.4785261394903697,0.5075277237019072,0 days 00:03:09.624000,38,"def f(x, y, m, n):
   result = (sqrt(18 * m) - 0.5 * (y ** m)) ** 101
   return x - resu",0 days 00:00:21.877000,63.208,27,3,0.8490486436316078,0.4640762772644813,0 days 00:22:47.535000,37,27,32,0 days 00:01:07.305000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator import attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __init__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path  from root to leaf""""""
        self.leaf = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(sell, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, noda):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
        if name == 'end':
            if self.leaf:
                return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""initiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represeted as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = None
        self.splitEnd = None
        self.size = -1  # Lengts of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (rick 1). If activeLength is greater
        than current edge length, set next  internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = self.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in  current extension and may change in
        next extension""""""
        node = Node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far n tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in tree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         it's suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos  # APCFALZ
            #  There is no outgoing edge starting with
            #  activeEdge from activeNode
            if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                # Extension Rule 2 (A new leaf edge gets created)
                self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                """"""A new leaf edge is created in above line starting
                 from  an existing node (the current activeNode), and
                 if there is any internal node waiting for it's suffix
                 link get reset, point the suffix link from that last
                 internal node to current activeNode. Then set lastNewNode
                 to None indicating no more node waiting for suffix link
                 reset.""""""
                if (self.lastNewNode is not None):
                    self.lastNewNode.suffixLink = self.activeNode
                    self.lastNewNode = None
            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.activeEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if (self._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent active node
                    if((self.lastNewNode is not None) and (self.activeNode != self.root)):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break
                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not  on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                  internal node get created""""""
                self.splitEnd = _next.start + self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.children[self._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for it's suffix link
                  reset, do it now.""""""
                if (self.lastNewNode is not None):
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                  for it's suffix link reset (which is pointing to self.root
                  at present). If we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies is any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node.""""""
                self.lastNewNode = split
                """"""One suffix got added in tree, decrement the count of
                suffixes yet to be added.""""""
                self.remainingSuffixCount -= 1
            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",0 days 00:19:40.425000,38,27,50,0 days 00:00:26.461000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""% self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                    ,edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
34,-1025449055294680256,"[2, 1, 1, 2, 1, 1, 2, 1, 3, 1, 1, 1, 2, 1, 2, 1, 2, 2, 3, 2]","[1, 5, 2, 6]",2022-08-26 11:49:54.006000+02:00,0 days 00:05:24.588000,72,"def calculate_math(x,y,m,n):
for n in range(0,100):
    pow((x+2y), m)/pow(n, (0.5*n))
",0 days 00:01:04.967000,108.19600000000001,18,3,0.3604569485008688,0.26803208991090244,0 days 00:05:02.080000,96,"def calculate_math(x,y,m):
    final_value = 1
    for n in range (0, 100):
        final_value =* math.sqrt(18*m) - 0.5 * pow (y, m)
    final value = x - final_value
    
    return final_value",0 days 00:00:38.067000,43.15428571428571,80,7,1.1586334745762712,0.6455243644067797,0 days 00:25:58.925000,71,29,71,0 days 00:00:33.331000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator import attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __init__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path  from root to leaf""""""
        self.leaf = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
            if name == 'end':
                if self.leaf:
                    return leafEnd
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""Initiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represeted as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = None
        self.splitEnd = None
        self.size = -1  # Lenghts of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick  (trick 1). If activeLength is greater
        than current edge length, set next  internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = sel.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in current extension and may change in
        next extension""""""
        node = Node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""suffixIndex will be set to -1 by default and
           actual suffix index will be set later for leaves
           at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far in tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in tree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
         indicating there is no internal node waiting for
         it's suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while(self.remainingSuffixCount > 0):
            if (self.activeLength == 0):
                self.activeEdge = pos  # APCFALZ
            #  There is no outgoing edge starting with
            #  activeEdge from activeNode
            if (self.activeNode.children.get(self._string[self.activeEdge]) is None):
                # Extension Rule 2 (A new leaf edge gets created)
                self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                """"""A new leaf edge is created in above line starting
                 from  an existng node (the current activeNode), and
                 if there is any internal node waiting for it's suffix
                 link get reset, point the suffix link from that last
                 internal node to current activeNode. Then set lastNewNode
                 to None indicating no more node waiting for suffix link
                 reset.""""""
                if (self.lastNewNode is not None):
                    self.lastNewNode.suffixLink = self.activeNode
                    self.lastNewNode = None
            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.activeEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if (self._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to curent active node
                    if ((self.lastNewNode is not None) and (self.activeNode != self.root)):
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break
            """"""We will be here when activePoint is in middle of
              the edge being traversed and current character
              being processed is not on the edge (we fall off
              the tree). In this case, we add a new internal node
              and a new leaf edge going out of that new node. This
              is Extension Rule 2, where a new leaf edge and a new
            internal node get created""""""
            self.splitEnd = _next.start ++ self.activeLength - 1
            # New internal node
            split = self.new_node(_next.start, self.splitEnd)
            self.activeNode.children[self._string[self.activeEdge]] = split
            # New leaf coming out of new internal node
            split.children[self._string[pos]] = self.new_node(pos, leaf=True)
            _next.start += self.activeLength
            split.children[self._string[_next.start]] = _next
            """"""We got a new internal node here. If there is any
              internal node created in last extensions of same
              phase which is still waiting for it's suffix link
              reset, do it now.""""""
            if (self.lastNewNode is not None):
                # suffixLink of lastNewNode points to current newly
                # created internal node
                self.lastNewNode.suffixLink = split
            """"""Make the current newly created internal node waiting
              for it's suffix link reset (which is pointing to self.root
              at present). If we come across any other internal node
              (existing or newly created) in next extension of same
              phase, when a new leaf edge gets added (i.e. when
              Extension Rule 2 applies is any of the next extension
              of same phase) at that point, suffixLink of this node
              will point to that internal node.""""""
            self.lastNewNode = split
            """"""One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
                self.remainingSuffixCount -= 1
            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",0 days 00:11:22.978000,37,22,35,0 days 00:00:31.142000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part represented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
            return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuff \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                    ,edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            self.active.last_char_index += 1
            self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
35,3172369203651549235,"[3, 2, 2, 1, 1, 2, 3, 1, 2, 1, 1, 1, 2, 1, 2, 1, 3, 3, 3, 2]","[5, 1, 6, 2]",2022-08-31 14:40:12.143000+02:00,0 days 00:01:27.140000,86,"def f(x, y, m,):
    return sum((x + 2y) ** m) / n ** (0.5*i) for i in range(101))",0 days 00:00:08.937000,43.57,15,2,1.2164333256828093,0.9410144594904751,0 days 00:02:22.433000,157,"def f(x, y, m, n):
    prod = 1
    for n in range(101):
        prod *= (18 * m) ** 0.5 - 0.5 * (y ** m)
    return x - pr",0 days 00:00:10.695000,28.4866,10,5,1.228647855482929,0.8635639212822872,0 days 00:10:32.408000,53,28,870,0 days 00:00:42.332000,"""""""An optimized implementation of Suffix-Tree.""""""

# For more information about the comments you can read 
from operator import attrgetter

leafEnd = -1


class Node:
    """"""The Suffix-tree's node.""""""

    def __init__(self, leaf):
        # self.__identifier = identifier
        self.children = {}
        # for leaf nodes, it stores the index of suffix for
        # the path  from root to leaf""""""
        self.leaf = leaf
        self.suffixIndex = None
        self.start = None
        self.end = None
        self.suffixLink = None

    def __eq__(sell, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) == atg(node)

    def __ne__(self, node):
        atg = attrgetter('start', 'end', 'suffixIndex')
        return atg(self) != atg(node)

    def __getattribute__(self, name):
        if name == 'end':
            if self.leaf:
                return leaf.end
        return super(Node, self).__getattribute__(name)


class SuffixTree:
    """"""The Suffix-Tree.""""""

    def __init__(self, data):
        """"""Initiate the tree.""""""
        self._string = data
        self.lastNewNode = None
        self.activeNode = None
        """"""activeEdge is represeted as input string character
          index (not the character itself)""""""
        self.activeEdge = -1
        self.activeLength = 0
        # remainingSuffixCount tells how many suffixes yet to
        # be added in tree
        self.remainingSuffixCount = 0
        self.rootEnd = None
        self.splitEnd = None
        self.size = -1  # Lengths of input string
        self.root = None

    def edge_length(self, node):
        return node.end - node.start + 1

    def walk_down(self, current_node):
        """"""Walk down from current node.
        activePoint change for walk down (APCFWD) using
        Skip/Count Trick (trick 1). If activeLength is greater
        than current edge length, set next internal node as
        activeNode and adjust activeEdge and activeLength
        accordingly to represent same activePoint.
        """"""
        length = self.edge_length(current_node)
        if (self.activeLength >= length):
            self.activeEdge += length
            self.activeLength -= length
            self.activeNode = current_node
            return True
        return False

    def new_node(self, start, end=None, leaf=False):
        """"""For root node, suffixLink will be set to NULL
        For internal nodes, suffixLink will be set to root
        by default in  current extension and may change in
        next extension""""""
        node = Node(leaf)
        node.suffixLink = self.root
        node.start = start
        node.end = end
        """"""suffixIndex will be set to -1 by default and
        actual suffix index will be set later for leaves
        at the end of all phases""""""
        node.suffixIndex = -1
        return node

    def extend_suffix_tree(self, pos):
        global leafEnd
        """"""Extension Rule 1, this takes care of extending all
        leaves created so far in tree""""""
        leafEnd = pos
        """"""Increment remainingSuffixCount indicating that a
        new suffix added to the list of suffixes yet to be
        added in tree""""""
        self.remainingSuffixCount += 1
        """"""set lastNewNode to None while starting a new phase,
        indicating there is no internal node waiting for
        its suffix link reset in current phase""""""
        self.lastNewNode = None
        # Add all suffixes (yet to be added) one by one in tree
        while self.remainingSuffixCount > 0:
            if self.activeLength == 0:
                self.activeEdge = pos  # APCFALZ
            #  There is no outgoing edge starting with
            #  activeEdge from activeNode
                if self.activeNode.children.get(self._string[self.activeEdge]) is None:
                # Extension Rule 2 (A new leaf edge gets created)
                self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)
                """"""A new leaf edge is created in above line starting
                 from  an existng node (the current activeNode), and
                 if there is any internal node waiting for its suffix
                 link get reset, point the suffix link from that last
                 internal node to current activeNode. Then set lastNewNode
                 to None indicating no more node waiting for suffix link
                 reset.""""""
                if self.lastNewNode is not None:
                    self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
            #  There is an outgoing edge starting with activeEdge
            #  from activeNode
            else:
                #  Get the next node at the end of edge starting
                #  with activeEdge
                _next = self.activeNode.children.get(self._string[self.activeEdge])
                if self.walk_down(_next):  # Do walkdown
                    # Start from _next node (the new activeNode)
                    continue
                """"""Extension Rule 3 (current character being processed
                  is already on the edge)""""""
                if (self._string[_next.start + self.activeLength] == self._string[pos]):
                    # If a newly created node waiting for it's
                    # suffix link to be set, then set suffix link
                    # of that waiting node to current active node
                    if self.lastNewNode is not None and self.activeNode != self.root:
                        self.lastNewNode.suffixLink = self.activeNode
                        self.lastNewNode = None
                    # APCFER3
                    self.activeLength += 1
                    """"""STOP all further processing in this phase
                    and move on to _next phase""""""
                    break
                """"""We will be here when activePoint is in middle of
                  the edge being traversed and current character
                  being processed is not on the edge (we fall off
                  the tree). In this case, we add a new internal node
                  and a new leaf edge going out of that new node. This
                  is Extension Rule 2, where a new leaf edge and a new
                internal node get created""""""
                self.splitEnd = _next.start ++ self.activeLength - 1
                # New internal node
                split = self.new_node(_next.start, self.splitEnd)
                self.activeNode.children[self._string[self.activeEdge]] = split
                # New leaf coming out of new internal node
                split.children[self._string[pos]] = self.new_node(pos, leaf=True)
                _next.start += self.activeLength
                split.children[self._string[_next.start]] = _next
                """"""We got a new internal node here. If there is any
                  internal node created in last extensions of same
                  phase which is still waiting for it's suffix link
                  reset, do it now.""""""
                if self.lastNewNode is not None:
                    # suffixLink of lastNewNode points to current newly
                    # created internal node
                    self.lastNewNode.suffixLink = split
                """"""Make the current newly created internal node waiting
                  for it's suffix link reset (which is pointing to self.root
                  at present). If we come across any other internal node
                  (existing or newly created) in next extension of same
                  phase, when a new leaf edge gets added (i.e. when
                  Extension Rule 2 applies in any of the next extension
                  of same phase) at that point, suffixLink of this node
                  will point to that internal node.""""""
                self.lastNewNode = split
            """"""One suffix got added in tree, decrement the count of
               suffixes yet to be added.""""""
                    self.remainingSuffixCount -= 1
            if self.activeNode == self.root and self.activeLength > 0:  # APCFER2C1
                self.activeLength -= 1
                self.activeEdge = pos - self.remainingSuffixCount + 1
            elif (self.activeNode != self.root):  # APCFER2C2
                self.activeNode = self.activeNode.suffixLink
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",0 days 00:06:42.903000,34,22,813,0 days 00:00:14.299000,"# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node
                                                edge.first_char_index,
                                                edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
