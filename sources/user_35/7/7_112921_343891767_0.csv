date,timestamp,fileName,fileHashCode,documentHashCode,fragment,userId,testMode,email,answers
2022-08-30 13:12:45.542000+02:00,0,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __inid__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:32:29.570000+02:00,0,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __inid__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:32:30.716000+02:00,47592,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node():
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __inid__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:32:30.722000+02:00,47711,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node):
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __inid__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:32:32.877000+02:00,47713,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __inid__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:32:32.966000+02:00,47848,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __ini__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:32:42.115000+02:00,47869,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:32:42.447000+02:00,48033,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" %self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:32:56.277000+02:00,48054,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:32:58.873000+02:00,48167,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:object):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:33:00.336000+02:00,48310,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge::
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:33:16.164000+02:00,48444,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:33:24.704000+02:00,48600,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:33:32.010000+02:00,48712,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:33:32.113000+02:00,48864,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(elf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:33:36.842000+02:00,48885,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:33:45.531000+02:00,49045,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:33:51.651000+02:00,49158,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:34:01.972000+02:00,49259,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:34:02.840000+02:00,49362,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)
d

class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:34:06.344000+02:00,49413,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:34:06.702000+02:00,49526,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix():
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:34:06.708000+02:00,49580,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:34:18.900000+02:00,49582,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:34:41.561000+02:00,49720,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:34:59.439000+02:00,49857,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:35:20.094000+02:00,49982,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:35:20.241000+02:00,50115,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree():
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:35:20.247000+02:00,50135,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:35:34.417000+02:00,50137,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:35:48.675000+02:00,50254,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:35:48.789000+02:00,50466,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in ange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:36:14.093000+02:00,50487,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:36:26.566000+02:00,50731,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:36:26.809000+02:00,50967,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" %(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:36:33.629000+02:00,50988,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:36:34.990000+02:00,51142,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     ,edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:36:40.966000+02:00,51307,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                    ,edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:36:42.182000+02:00,51452,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                    ,edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:36:42.787000+02:00,51640,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    ,edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:36:43.420000+02:00,51795,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:37:07.066000+02:00,51930,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:37:07.509000+02:00,52106,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)

            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:37:42.052000+02:00,52264,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:37:57.265000+02:00,52434,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:37:58.605000+02:00,52763,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, seld.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:37:59.035000+02:00,52803,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:38:15.114000+02:00,52843,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:38:21.172000+02:00,53058,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:38:37.015000+02:00,53249,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:38:47.678000+02:00,53452,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:38:47.683000+02:00,53694,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:38:48.750000+02:00,53696,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.a(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:39:13.841000+02:00,53758,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:39:35.662000+02:00,53902,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:39:57.599000+02:00,54061,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:39:58.238000+02:00,54208,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
            
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:39:58.243000+02:00,54330,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
           
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:40:54.078000+02:00,54332,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:41:25.429000+02:00,54458,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:41:25.433000+02:00,54619,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cannize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:41:44.453000+02:00,54621,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:42:19.668000+02:00,54788,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:42:42.383000+02:00,54953,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:42:47.751000+02:00,55083,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:44:07.221000+02:00,55283,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:44:07.603000+02:00,55507,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        ndex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:44:20.890000+02:00,55516,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:44:21.436000+02:00,55658,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the uffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:44:37.856000+02:00,55760,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
2022-08-30 13:44:38.356000+02:00,55883,7.ipynb,112921,343891767,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node:
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge:
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        , self.first_char_index, self.last_char_index)


class Suffix:
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thn last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree:
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    , edge.dest_node_index
                    , self.nodes[edge.dest_node_index].suffix_node
                    , edge.first_char_index
                    , edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.append(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",20,OFF,-339099788494146227,"[2, 3, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1]"
