date,timestamp,fileName,fileHashCode,documentHashCode,fragment,userId,testMode,email,answers
2022-09-02 13:06:36.431000+02:00,0,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __inid__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:03.983000+02:00,0,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __inid__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:04.094000+02:00,54261,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the uffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __inid__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:11.389000+02:00,54282,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __inid__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:28.871000+02:00,54415,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __inid__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:29.145000+02:00,54508,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __ini__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:48.589000+02:00,54529,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:48.846000+02:00,54701,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node 

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:49.314000+02:00,54722,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:50.115000+02:00,54768,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  #

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:50.367000+02:00,54862,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # 

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:50.648000+02:00,54883,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:51.009000+02:00,54920,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # Id

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:51.133000+02:00,54944,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:51.222000+02:00,54965,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I 

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:51.341000+02:00,54986,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I d

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:51.446000+02:00,55023,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I dn

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:51.643000+02:00,55044,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I dno

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:52.050000+02:00,55065,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I dnot

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:52.207000+02:00,55095,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I dno

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:52.342000+02:00,55116,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I dn

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:53.042000+02:00,55137,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I d

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:53.274000+02:00,55262,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I do

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:53.753000+02:00,55299,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I dot

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:53.915000+02:00,55396,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I do

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:54.321000+02:00,55417,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:54.438000+02:00,55461,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don'

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:54.565000+02:00,55482,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:54.703000+02:00,55519,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't 

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:54.845000+02:00,55540,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't k

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:54.966000+02:00,55577,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't kn

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:55.051000+02:00,55598,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't kno

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:55.158000+02:00,55619,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:55.356000+02:00,55640,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know 

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:55.485000+02:00,55661,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know w

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:55.570000+02:00,55698,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know wh

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:55.735000+02:00,55719,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know wha

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:55.874000+02:00,55740,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:56.125000+02:00,55761,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what 

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:56.253000+02:00,55782,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what t

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:56.316000+02:00,55819,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what th

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:56.410000+02:00,55840,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what thi

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:56.512000+02:00,55861,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:56.612000+02:00,55882,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this 

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:56.714000+02:00,55903,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this i

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:56.846000+02:00,55940,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:57.290000+02:00,55961,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is 

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:59.099000+02:00,55999,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:59.479000+02:00,56087,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is.

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:59.774000+02:00,56126,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. 

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:31:59.928000+02:00,56147,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:00.132000+02:00,56184,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I 

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:00.227000+02:00,56205,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I u

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:00.425000+02:00,56242,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I us

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:00.635000+02:00,56263,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:00.785000+02:00,56284,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use 

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:01.421000+02:00,56305,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:01.556000+02:00,56434,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:01.761000+02:00,56455,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-s

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:01.840000+02:00,56492,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-st

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:01.927000+02:00,56513,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-str

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:02.082000+02:00,56534,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-stri

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:02.211000+02:00,56555,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strin

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:02.586000+02:00,56576,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-string

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:03.029000+02:00,56602,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:03.848000+02:00,56636,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings 

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:04.299000+02:00,56727,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:04.608000+02:00,56789,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:11.186000+02:00,56810,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:26.852000+02:00,56899,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:27.290000+02:00,57127,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object): 
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:27.759000+02:00,57167,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object): #
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:27.855000+02:00,57216,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object): # 
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:28.156000+02:00,57237,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object): # w
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:28.325000+02:00,57274,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object): # 
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:28.467000+02:00,57295,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object): #
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:28.615000+02:00,57316,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object): 
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:29.043000+02:00,57341,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:29.420000+02:00,57393,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  W
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:30.040000+02:00,57468,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:30.218000+02:00,57606,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  #
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:30.365000+02:00,57633,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # 
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:30.612000+02:00,57654,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # w
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:30.715000+02:00,57691,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # wh
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:30.802000+02:00,57712,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:30.913000+02:00,57733,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why 
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:31.096000+02:00,57754,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why e
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:31.235000+02:00,57791,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why ex
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:31.534000+02:00,57812,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why exp
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:32.225000+02:00,57833,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why expl
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:32.327000+02:00,57931,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why expli
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:32.450000+02:00,57952,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explic
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:32.552000+02:00,57973,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explici
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:33.709000+02:00,57994,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:34.018000+02:00,58099,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit 
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:34.244000+02:00,58120,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit o
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:34.364000+02:00,58157,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit ob
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:34.447000+02:00,58178,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit obj
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:34.532000+02:00,58199,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit obje
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:34.767000+02:00,58220,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit objec
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:34.987000+02:00,58241,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:41.685000+02:00,58262,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:41.691000+02:00,58355,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:43.159000+02:00,58357,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""
    
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:43.164000+02:00,58355,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:44.267000+02:00,58262,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:44.272000+02:00,58573,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:45.206000+02:00,58575,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""
    
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:45.210000+02:00,58573,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:48.164000+02:00,58262,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:48.169000+02:00,58712,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:51.021000+02:00,58714,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""
    
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:51.027000+02:00,58791,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:51.984000+02:00,58793,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""
    \An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:32:56.261000+02:00,58893,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:33:12.466000+02:00,59011,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:33:25.599000+02:00,59110,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:33:25.602000+02:00,59263,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
       def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:33:37.923000+02:00,59265,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:33:43.588000+02:00,59392,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:33:43.747000+02:00,59504,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
,self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:33:45.226000+02:00,59525,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:33:45.248000+02:00,59629,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:08.400000+02:00,59658,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:08.916000+02:00,59758,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) 

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:09.106000+02:00,59798,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) N

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:09.283000+02:00,59835,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) No

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:09.393000+02:00,59856,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:09.518000+02:00,59877,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not 

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:09.554000+02:00,59898,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not t

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:09.799000+02:00,59923,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not th

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:09.990000+02:00,59960,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:10.136000+02:00,59981,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the 

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:10.223000+02:00,60002,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the s

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:10.332000+02:00,60039,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the sa

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:10.464000+02:00,60060,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the sam

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:10.584000+02:00,60081,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:10.689000+02:00,60102,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same 

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:10.793000+02:00,60123,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same a

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:10.926000+02:00,60160,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:11.288000+02:00,60181,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as 

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:11.482000+02:00,60207,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as o

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:11.592000+02:00,60244,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:11.676000+02:00,60265,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on 

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:11.880000+02:00,60286,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on l

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:11.997000+02:00,60323,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on li

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:12.081000+02:00,60344,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on lin

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:12.195000+02:00,60365,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:12.752000+02:00,60386,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:12.846000+02:00,60479,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 4

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:14.902000+02:00,60516,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:14.919000+02:00,60621,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:15.608000+02:00,60650,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
    

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:16.593000+02:00,60769,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:16.772000+02:00,60853,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        #

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:16.945000+02:00,60880,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # 

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:17.033000+02:00,60901,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # r

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:17.190000+02:00,60938,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # re

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:17.279000+02:00,60959,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # ret

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:17.377000+02:00,60980,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # retu

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:17.465000+02:00,61001,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # retur

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:17.598000+02:00,61022,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:21.934000+02:00,61043,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:23.632000+02:00,61132,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:23.841000+02:00,61249,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return Node(suffix link: %d)""%self.suffix_node

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:26.369000+02:00,61270,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)""%self.suffix_node

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:26.660000+02:00,61371,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)%self.suffix_node

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:27.552000+02:00,61392,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'%self.suffix_node

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:28.164000+02:00,61493,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% self.suffix_node

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:30.216000+02:00,61600,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:47.328000+02:00,61696,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:34:52.211000+02:00,61792,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:35:02.471000+02:00,61925,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:35:03.631000+02:00,62050,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        ndex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:35:22.501000+02:00,62140,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:35:30.025000+02:00,62282,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:35:45.838000+02:00,62395,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:35:52.883000+02:00,62549,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:35:53.007000+02:00,62688,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater thn last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:35:59.174000+02:00,62709,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:00.946000+02:00,62808,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:01.187000+02:00,62904,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index 


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:01.968000+02:00,62925,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:02.228000+02:00,63015,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  #


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:02.957000+02:00,63042,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # 


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:03.085000+02:00,63181,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:03.363000+02:00,63202,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:03.508000+02:00,63223,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>=


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:03.726000+02:00,63244,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= 


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:03.877000+02:00,63265,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= i


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:04.035000+02:00,63302,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:04.174000+02:00,63323,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is 


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:04.311000+02:00,63344,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:04.701000+02:00,63381,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a 


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:04.833000+02:00,63413,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a H


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:04.903000+02:00,63450,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Ha


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:05.030000+02:00,63471,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Has


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:05.125000+02:00,63492,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Hask


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:05.233000+02:00,63513,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haske


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:05.367000+02:00,63534,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskel


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:05.436000+02:00,63555,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:05.534000+02:00,63576,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell 


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:05.652000+02:00,63597,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell t


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:05.765000+02:00,63634,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell th


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:05.972000+02:00,63655,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thi


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:06.569000+02:00,63676,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thin


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:06.880000+02:00,63776,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:06.971000+02:00,63797,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing,


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:07.052000+02:00,63818,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, 


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:07.116000+02:00,63839,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, s


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:07.298000+02:00,63876,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, so


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:07.447000+02:00,63897,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sor


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:07.532000+02:00,63918,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorr


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:20.556000+02:00,63939,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:38.319000+02:00,64058,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:36:38.323000+02:00,64156,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
           self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:37:15.305000+02:00,64158,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:37:15.561000+02:00,64369,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in ange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:37:24.614000+02:00,64390,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:37:42.185000+02:00,64554,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:38:03.146000+02:00,64701,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:38:03.298000+02:00,64978,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:38:04.246000+02:00,64999,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:38:04.273000+02:00,65145,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
            edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:38:07.987000+02:00,65174,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:38:08.157000+02:00,65303,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index
,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:38:09.029000+02:00,65324,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:38:12.296000+02:00,65448,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:38:12.444000+02:00,65634,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node
edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:38:13.246000+02:00,65655,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_nodeedge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:38:13.431000+02:00,65814,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:38:16.756000+02:00,65844,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:38:17.200000+02:00,65976,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index
,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:38:18.591000+02:00,66034,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:38:37.138000+02:00,66201,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:38:39.969000+02:00,66319,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)

            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:38:43.887000+02:00,66430,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:39:04.988000+02:00,66584,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:39:05.496000+02:00,66765,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index: top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:39:12.968000+02:00,66786,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:39:34.621000+02:00,66906,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:39:34.626000+02:00,67061,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
               if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:40:11.328000+02:00,67063,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:40:16.353000+02:00,67320,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:40:56.599000+02:00,67464,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:40:56.604000+02:00,67599,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:41:18.154000+02:00,67601,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:41:50.332000+02:00,67772,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:41:50.647000+02:00,67931,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cannize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:42:13.194000+02:00,67952,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:42:41.617000+02:00,68173,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:43:01.736000+02:00,68413,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:43:06.043000+02:00,68602,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:43:06.246000+02:00,68764,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ###need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:43:06.400000+02:00,68785,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ##need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:43:07.124000+02:00,68806,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  #need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:43:24.357000+02:00,68917,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:43:59.856000+02:00,69030,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:43:59.860000+02:00,69180,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                   suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:28.645000+02:00,69182,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:29.494000+02:00,69396,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods 
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:29.788000+02:00,69514,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods ,
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:30.370000+02:00,69535,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods ,_
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:30.549000+02:00,69680,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods ,
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:31.106000+02:00,69701,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods 
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:31.482000+02:00,69817,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:31.712000+02:00,69873,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <-
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:32.174000+02:00,69894,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- 
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:32.258000+02:00,69977,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- i
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:32.388000+02:00,70014,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- is
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:32.559000+02:00,70035,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- is 
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:32.684000+02:00,70056,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- is t
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:32.770000+02:00,70093,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- is th
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:32.835000+02:00,70114,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- is thi
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:32.948000+02:00,70135,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- is this
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:33.044000+02:00,70156,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- is this 
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:33.140000+02:00,70177,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- is this c
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:33.296000+02:00,70214,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- is this co
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:33.975000+02:00,70235,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- is this com
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:34.480000+02:00,70373,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- is this co
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:34.506000+02:00,70479,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- is this c
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:34.554000+02:00,70500,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- is this 
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:34.580000+02:00,70521,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- is this
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:34.614000+02:00,70542,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- is thi
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:34.647000+02:00,70563,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- is th
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:34.708000+02:00,70584,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- is t
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:34.717000+02:00,70605,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- is 
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:34.833000+02:00,70607,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- is
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:35.001000+02:00,70628,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- i
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:35.344000+02:00,70649,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- 
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:35.547000+02:00,70683,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- w
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:35.633000+02:00,70720,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- wh
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:35.790000+02:00,70741,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- wha
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:35.913000+02:00,70762,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:36.315000+02:00,70783,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what 
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:36.486000+02:00,70862,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what v
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:36.577000+02:00,70899,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what va
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:36.749000+02:00,70920,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what val
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:36.847000+02:00,70941,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what valu
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:36.962000+02:00,70962,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:37.317000+02:00,70983,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value 
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:37.479000+02:00,71048,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value d
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:37.595000+02:00,71085,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value do
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:37.700000+02:00,71106,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value doe
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:37.814000+02:00,71127,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:38.188000+02:00,71148,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does 
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:38.288000+02:00,71188,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does t
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:38.371000+02:00,71225,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does th
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:38.438000+02:00,71246,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does thi
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:38.551000+02:00,71267,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:38.628000+02:00,71288,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this 
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:38.751000+02:00,71309,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this c
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:38.975000+02:00,71346,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this co
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:39.113000+02:00,71367,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this com
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:39.184000+02:00,71388,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comm
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:39.318000+02:00,71409,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comme
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:39.380000+02:00,71430,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this commen
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:39.473000+02:00,71451,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:39.940000+02:00,71472,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment 
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:40.034000+02:00,71590,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment b
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:40.142000+02:00,71627,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment br
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:40.284000+02:00,71648,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bri
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:40.385000+02:00,71669,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment brin
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:40.649000+02:00,71690,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:48.491000+02:00,71711,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:48.495000+02:00,71844,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:51.212000+02:00,71846,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:51.486000+02:00,72052,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        
        """"Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:51.714000+02:00,72163,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        
        ""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:52.435000+02:00,72184,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        
        Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:52.440000+02:00,72236,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
       
        Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:53.381000+02:00,72238,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
    
        Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:53.385000+02:00,72389,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
   
        Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:53.787000+02:00,72391,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""

        Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:44:59.650000+02:00,72439,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:08.969000+02:00,72550,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:27.763000+02:00,72665,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:28.222000+02:00,72859,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: 
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:28.416000+02:00,72929,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: #
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:28.663000+02:00,72956,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # 
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:28.797000+02:00,72977,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # i
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:28.946000+02:00,73014,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:30.136000+02:00,73035,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is 
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:30.250000+02:00,73175,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is ""
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:30.375000+02:00,73196,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """"
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:30.732000+02:00,73217,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" 
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:31.213000+02:00,73292,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" o
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:31.628000+02:00,73400,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" 
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:31.744000+02:00,73449,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" n
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:31.875000+02:00,73486,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" no
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:31.964000+02:00,73507,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:32.091000+02:00,73528,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not 
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:32.201000+02:00,73549,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:32.557000+02:00,73586,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a 
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:32.723000+02:00,73634,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a s
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:32.977000+02:00,73671,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a su
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:33.151000+02:00,73692,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a sub
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:33.392000+02:00,73713,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a subs
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:33.466000+02:00,73734,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a subst
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:33.541000+02:00,73755,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substr
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:33.686000+02:00,73776,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substri
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:33.807000+02:00,73797,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substrin
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:34.273000+02:00,73818,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substring
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:34.448000+02:00,73921,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substring 
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:34.562000+02:00,73942,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substring o
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:34.670000+02:00,73979,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substring of
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:34.787000+02:00,74000,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substring of 
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:34.997000+02:00,74021,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substring of a
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:35.685000+02:00,74058,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substring of an
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:35.923000+02:00,74176,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substring of ant
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:36.061000+02:00,74197,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substring of antr
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:36.167000+02:00,74218,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substring of antrh
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:36.314000+02:00,74239,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substring of antrhi
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:36.432000+02:00,74260,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substring of antrhin
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:37.261000+02:00,74281,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substring of antrhing
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:37.746000+02:00,74433,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substring of antrhing?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:37.970000+02:00,74518,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substring of antrhing? 
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:38.098000+02:00,74539,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substring of antrhing? W
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:38.275000+02:00,74576,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substring of antrhing? Wh
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:38.374000+02:00,74597,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substring of antrhing? Why
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:38.480000+02:00,74618,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substring of antrhing? Why 
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:38.557000+02:00,74639,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substring of antrhing? Why n
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:38.642000+02:00,74676,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substring of antrhing? Why no
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:38.925000+02:00,74697,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substring of antrhing? Why not
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:39.912000+02:00,74718,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substring of antrhing? Why not>
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:40.192000+02:00,74835,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substring of antrhing? Why not
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:43.816000+02:00,74856,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring: # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:45:56.017000+02:00,74963,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:11.364000+02:00,75097,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:11.548000+02:00,75274,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i) 
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:11.982000+02:00,75295,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:12.201000+02:00,75367,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  #
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:12.776000+02:00,75394,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # 
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:13.054000+02:00,75533,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:13.247000+02:00,75570,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A 
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:13.376000+02:00,75591,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A v
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:13.539000+02:00,75628,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vr
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:13.735000+02:00,75649,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrt
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:13.822000+02:00,75670,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:13.979000+02:00,75691,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty 
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:14.087000+02:00,75712,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty m
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:14.190000+02:00,75749,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty me
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:14.275000+02:00,75770,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty mea
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:14.412000+02:00,75791,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty mean
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:14.564000+02:00,75812,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty meani
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:14.737000+02:00,75833,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty meanin
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:14.925000+02:00,75854,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty meaning
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:15.041000+02:00,75875,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty meaningf
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:15.228000+02:00,75896,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty meaningfu
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:15.364000+02:00,75917,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty meaningful
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:15.441000+02:00,75938,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty meaningful 
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:15.511000+02:00,75959,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty meaningful n
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:15.617000+02:00,75996,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty meaningful na
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:15.703000+02:00,76017,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty meaningful nam
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:15.869000+02:00,76038,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty meaningful name
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:16.020000+02:00,76059,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty meaningful name,
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:16.190000+02:00,76080,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty meaningful name, 
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:16.383000+02:00,76101,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty meaningful name, t
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:16.483000+02:00,76138,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty meaningful name, th
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:16.614000+02:00,76159,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty meaningful name, tha
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:16.742000+02:00,76180,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty meaningful name, than
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:16.829000+02:00,76201,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty meaningful name, thank
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:16.988000+02:00,76222,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty meaningful name, thank 
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:17.213000+02:00,76243,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty meaningful name, thank y
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:17.393000+02:00,76280,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty meaningful name, thank yo
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:17.798000+02:00,76301,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty meaningful name, thank you
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:21.154000+02:00,76380,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vrty meaningful name, thank you!
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:21.297000+02:00,76525,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vry meaningful name, thank you!
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:21.636000+02:00,76546,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vy meaningful name, thank you!
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:21.764000+02:00,76570,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vwy meaningful name, thank you!
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:22.842000+02:00,76607,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vwry meaningful name, thank you!
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:22.994000+02:00,76745,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vwy meaningful name, thank you!
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:23.307000+02:00,76766,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vy meaningful name, thank you!
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:23.437000+02:00,76787,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A vey meaningful name, thank you!
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:47.114000+02:00,76824,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A very meaningful name, thank you!
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:48.205000+02:00,76952,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index :top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A very meaningful name, thank you!
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:49.138000+02:00,77024,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A very meaningful name, thank you!
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
2022-09-02 13:46:49.408000+02:00,77086,7.ipynb,27664,158565894,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):  # why explicit object?
    """"""
    A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node  # I don't know what this is. I use f-strings ;^) Not the same as on line 41
        # return 'Node(suffix link: %d)'% (self.suffix_node)

class Edgeobject():
    """"""
    An edge in the suffix tree.
    
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index,
                                        self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""
    Represents a suffix from first_char_index to last_char_index.
    
    source_node_index
        index of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""
        A suffix is explicit if it ends on a node. first_char_index
        is set greater than last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >= self.first_char_index  # >>= is a Haskell thing, sorry


class SuffixTree(object):
    """"""
    A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index,
                                                edge.dest_node_index,
                                                self.nodes[edge.dest_node_index].suffix_node,
                                                edge.first_char_index,
                                                edge.last_char_index)
            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top +1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""
        The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)

            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node())
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  # need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""
        This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods <- what value does this comment bring?
    def find_substring(self, substring):
        """"""
        Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:  # is """" not a substring of antrhing? Why not?
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)  # A very meaningful name, thank you!
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",61,OFF,-8223556074798571371,"[3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 1, 2, 1, 1, 3, 2, 3, 3, 2, 1]"
