date,timestamp,fileName,fileHashCode,documentHashCode,fragment,userId,testMode,email,answers
2022-10-11 19:10:57.127000+02:00,0,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __inid__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:34:57.104000+02:00,0,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the puffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __inid__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:34:57.252000+02:00,39915,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the uffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __inid__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:35:19.979000+02:00,39936,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __inid__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:35:20.112000+02:00,40287,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __ini__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:35:27.823000+02:00,40308,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)""%self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:35:28.111000+02:00,40701,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" %self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:35:43.359000+02:00,40722,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:35:43.362000+02:00,41075,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

        suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:35:43.366000+02:00,41077,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

        suffix_node
            the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:35:50.069000+02:00,41079,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

        suffix_node
            the index of a node with a matching suffix, representing a suffix link.
            -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:35:50.073000+02:00,41077,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

        suffix_node
            the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:35:50.076000+02:00,41075,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

        suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:35:53.708000+02:00,40722,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

    suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:35:53.713000+02:00,41822,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

     suffix_node
        the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:35:53.716000+02:00,41824,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

     suffix_node
         the index of a node with a matching suffix, representing a suffix link.
        -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:35:54.072000+02:00,41826,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

     suffix_node
         the index of a node with a matching suffix, representing a suffix link.
         -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:35:54.075000+02:00,42183,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

      suffix_node
         the index of a node with a matching suffix, representing a suffix link.
         -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:35:54.078000+02:00,42185,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

      suffix_node
          the index of a node with a matching suffix, representing a suffix link.
         -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:35:54.334000+02:00,42187,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

      suffix_node
          the index of a node with a matching suffix, representing a suffix link.
          -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:35:54.338000+02:00,42208,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
          the index of a node with a matching suffix, representing a suffix link.
          -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:35:54.341000+02:00,42210,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
          -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:02.683000+02:00,42212,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edgeobject):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:11.925000+02:00,42558,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
    first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:11.929000+02:00,43050,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
     first_char_index
        index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:11.933000+02:00,43052,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
     first_char_index
         index of start of string part represented by this edge
    last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:11.936000+02:00,43054,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
     first_char_index
         index of start of string part represented by this edge
     last_char_index
        index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:11.940000+02:00,43056,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
     first_char_index
         index of start of string part represented by this edge
     last_char_index
         index of end of string part epresented by this edge
    source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:11.943000+02:00,43058,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
     first_char_index
         index of start of string part represented by this edge
     last_char_index
         index of end of string part epresented by this edge
     source_node_index
        index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:11.947000+02:00,43060,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
     first_char_index
         index of start of string part represented by this edge
     last_char_index
         index of end of string part epresented by this edge
     source_node_index
         index of source node of edge
    dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:11.951000+02:00,43062,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
     first_char_index
         index of start of string part represented by this edge
     last_char_index
         index of end of string part epresented by this edge
     source_node_index
         index of source node of edge
     dest_node_index
        index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:12.206000+02:00,43064,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
     first_char_index
         index of start of string part represented by this edge
     last_char_index
         index of end of string part epresented by this edge
     source_node_index
         index of source node of edge
     dest_node_index
         index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:12.210000+02:00,43085,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
      first_char_index
         index of start of string part represented by this edge
     last_char_index
         index of end of string part epresented by this edge
     source_node_index
         index of source node of edge
     dest_node_index
         index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:12.214000+02:00,43087,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
      first_char_index
          index of start of string part represented by this edge
     last_char_index
         index of end of string part epresented by this edge
     source_node_index
         index of source node of edge
     dest_node_index
         index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:12.217000+02:00,43089,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
      first_char_index
          index of start of string part represented by this edge
      last_char_index
         index of end of string part epresented by this edge
     source_node_index
         index of source node of edge
     dest_node_index
         index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:12.221000+02:00,43091,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
      first_char_index
          index of start of string part represented by this edge
      last_char_index
          index of end of string part epresented by this edge
     source_node_index
         index of source node of edge
     dest_node_index
         index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:12.224000+02:00,43093,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
      first_char_index
          index of start of string part represented by this edge
      last_char_index
          index of end of string part epresented by this edge
      source_node_index
         index of source node of edge
     dest_node_index
         index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:12.228000+02:00,43095,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
      first_char_index
          index of start of string part represented by this edge
      last_char_index
          index of end of string part epresented by this edge
      source_node_index
          index of source node of edge
     dest_node_index
         index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:12.232000+02:00,43097,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
      first_char_index
          index of start of string part represented by this edge
      last_char_index
          index of end of string part epresented by this edge
      source_node_index
          index of source node of edge
      dest_node_index
         index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:12.616000+02:00,43099,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
      first_char_index
          index of start of string part represented by this edge
      last_char_index
          index of end of string part epresented by this edge
      source_node_index
          index of source node of edge
      dest_node_index
          index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:12.620000+02:00,43446,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
          index of start of string part represented by this edge
      last_char_index
          index of end of string part epresented by this edge
      source_node_index
          index of source node of edge
      dest_node_index
          index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:12.623000+02:00,43448,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
      last_char_index
          index of end of string part epresented by this edge
      source_node_index
          index of source node of edge
      dest_node_index
          index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:12.626000+02:00,43450,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
          index of end of string part epresented by this edge
      source_node_index
          index of source node of edge
      dest_node_index
          index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:12.629000+02:00,43452,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part epresented by this edge
      source_node_index
          index of source node of edge
      dest_node_index
          index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:12.632000+02:00,43454,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part epresented by this edge
       source_node_index
          index of source node of edge
      dest_node_index
          index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:12.634000+02:00,43456,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part epresented by this edge
       source_node_index
           index of source node of edge
      dest_node_index
          index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:12.637000+02:00,43458,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part epresented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
          index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:23.091000+02:00,43460,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part epresented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:40.558000+02:00,43823,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        elf.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:52.701000+02:00,44217,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
        def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:52.705000+02:00,44585,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
       def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:59.396000+02:00,44587,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(pelf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:36:59.604000+02:00,44986,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(elf):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:04.954000+02:00,45007,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:07.757000+02:00,45435,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:07.761000+02:00,45734,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                       ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:08.287000+02:00,45736,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                    ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:08.290000+02:00,46083,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                   ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:08.538000+02:00,46085,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                                ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:08.541000+02:00,46106,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                               ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:08.698000+02:00,46108,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                            ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:08.701000+02:00,46129,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                           ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:08.829000+02:00,46131,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:08.834000+02:00,46152,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                       ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:08.965000+02:00,46154,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                    ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:08.969000+02:00,46175,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                   ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:09.089000+02:00,46177,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
                ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:09.093000+02:00,46198,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
               ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:09.227000+02:00,46200,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
            ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:09.231000+02:00,46221,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
           ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:09.369000+02:00,46223,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
        ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:09.372000+02:00,46244,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
       ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:09.686000+02:00,46246,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
    ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:09.690000+02:00,46267,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
   ,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:10.154000+02:00,46269,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index
,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:11.075000+02:00,46619,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:11.096000+02:00,46972,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
        self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:14.200000+02:00,47001,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index )


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:35.411000+02:00,47389,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
    source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:35.415000+02:00,47755,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
     source_node_index
        andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:35.419000+02:00,47757,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
     source_node_index
         andex of node where this suffix starts
    first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:35.422000+02:00,47759,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
     source_node_index
         andex of node where this suffix starts
     first_char_index
        index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:35.426000+02:00,47761,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
     source_node_index
         andex of node where this suffix starts
     first_char_index
         index of start of suffix in string
    last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:35.430000+02:00,47763,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
     source_node_index
         andex of node where this suffix starts
     first_char_index
         index of start of suffix in string
     last_char_index
        index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:35.776000+02:00,47765,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
     source_node_index
         andex of node where this suffix starts
     first_char_index
         index of start of suffix in string
     last_char_index
         index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:35.780000+02:00,47921,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
      source_node_index
         andex of node where this suffix starts
     first_char_index
         index of start of suffix in string
     last_char_index
         index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:35.783000+02:00,47923,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
      source_node_index
          andex of node where this suffix starts
     first_char_index
         index of start of suffix in string
     last_char_index
         index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:35.787000+02:00,47925,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
      source_node_index
          andex of node where this suffix starts
      first_char_index
         index of start of suffix in string
     last_char_index
         index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:35.791000+02:00,47927,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
      source_node_index
          andex of node where this suffix starts
      first_char_index
          index of start of suffix in string
     last_char_index
         index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:35.794000+02:00,47929,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
      source_node_index
          andex of node where this suffix starts
      first_char_index
          index of start of suffix in string
      last_char_index
         index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:35.989000+02:00,47931,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
      source_node_index
          andex of node where this suffix starts
      first_char_index
          index of start of suffix in string
      last_char_index
          index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:35.993000+02:00,47952,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
          andex of node where this suffix starts
      first_char_index
          index of start of suffix in string
      last_char_index
          index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:35.997000+02:00,47954,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           andex of node where this suffix starts
      first_char_index
          index of start of suffix in string
      last_char_index
          index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:36+02:00,47956,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           andex of node where this suffix starts
       first_char_index
          index of start of suffix in string
      last_char_index
          index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:36.004000+02:00,47958,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           andex of node where this suffix starts
       first_char_index
           index of start of suffix in string
      last_char_index
          index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:36.007000+02:00,47960,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           andex of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
          index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:39.299000+02:00,47962,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           andex of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:39.593000+02:00,48359,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           ndex of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:37:56.375000+02:00,48380,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index [= source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:38:05.013000+02:00,48717,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        retrn self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:38:15.936000+02:00,49140,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
        is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:38:16.166000+02:00,49531,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
         is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:38:16.560000+02:00,49552,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
          is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:38:24.628000+02:00,49651,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater thun last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:38:24.874000+02:00,49763,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater thn last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:38:48.809000+02:00,49784,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:38:49.014000+02:00,49914,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
     for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:38:49.196000+02:00,49935,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
      for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:39:11.902000+02:00,49956,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
            self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:39:11.906000+02:00,50065,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
           self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:39:29.022000+02:00,50067,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in lange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:39:29.362000+02:00,50255,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in ange(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:39:42.882000+02:00,50308,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tre
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:39:57.871000+02:00,50541,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lmbda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:10.325000+02:00,50721,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t""%(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:10.625000+02:00,50939,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" %(edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:21.784000+02:00,50960,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:21.787000+02:00,51118,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                   ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:22.422000+02:00,51120,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
                ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:22.426000+02:00,51288,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
               ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:22.636000+02:00,51290,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
            ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:22.640000+02:00,51311,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
           ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:22.942000+02:00,51313,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
        ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:22.946000+02:00,51334,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
       ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:23.272000+02:00,51336,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
    ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:23.276000+02:00,51360,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
   ,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:23.612000+02:00,51362,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index
,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:24.585000+02:00,51466,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index,edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:28.560000+02:00,51625,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, edge.dest_node_index
                    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:28.564000+02:00,51821,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, edge.dest_node_index
                   ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:28.825000+02:00,51823,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, edge.dest_node_index
                ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:28.829000+02:00,51844,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, edge.dest_node_index
               ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:29+02:00,51846,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, edge.dest_node_index
            ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:29.003000+02:00,51867,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, edge.dest_node_index
           ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:29.230000+02:00,51869,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, edge.dest_node_index
        ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:29.234000+02:00,51890,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, edge.dest_node_index
       ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:29.493000+02:00,51892,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, edge.dest_node_index
    ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:29.497000+02:00,51913,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, edge.dest_node_index
   ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:29.885000+02:00,51915,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, edge.dest_node_index
,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:30.408000+02:00,52069,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, edge.dest_node_index,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:33.794000+02:00,52220,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, edge.dest_node_index ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:34.067000+02:00,52409,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, edge.dest_node_index ,self.nodes[edg.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:35.070000+02:00,52430,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, edge.dest_node_index ,self.nodes[ed.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:35.074000+02:00,52409,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, edge.dest_node_index ,self.nodes[edg.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:37.961000+02:00,52220,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, edge.dest_node_index ,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:40.077000+02:00,52745,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, edge.dest_node_index,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:40.096000+02:00,52914,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
            edge.dest_node_index,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:41.971000+02:00,52943,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:44.527000+02:00,53131,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node
                     edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:45.101000+02:00,53314,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node
                    edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:45.104000+02:00,53466,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node
                   edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:45.581000+02:00,53468,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node
                edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:45.585000+02:00,53641,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node
               edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:45.715000+02:00,53643,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node
            edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:45.719000+02:00,53664,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node
           edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:45.894000+02:00,53666,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node
        edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:45.898000+02:00,53687,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node
       edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:46.172000+02:00,53689,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node
    edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:46.176000+02:00,53710,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node
   edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:46.566000+02:00,53712,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node
edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:47.133000+02:00,53899,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_nodeedge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:47.619000+02:00,54092,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:49.932000+02:00,54264,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index
                    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:49.936000+02:00,54434,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index
                   ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:50.081000+02:00,54436,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index
                ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:50.085000+02:00,54457,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index
               ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:50.264000+02:00,54459,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index
            ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:50.268000+02:00,54480,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index
           ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:50.495000+02:00,54482,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index
        ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:50.499000+02:00,54503,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index
       ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:50.774000+02:00,54505,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index
    ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:50.778000+02:00,54526,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index
   ,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:51.078000+02:00,54528,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index
,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:40:51.990000+02:00,54549,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:41:08.642000+02:00,54749,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:41:08.878000+02:00,54932,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index :top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:41:09.708000+02:00,54953,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index : top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:41:10.588000+02:00,54932,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index :top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:41:12.311000+02:00,54749,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:41:12.548000+02:00,55415,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top +1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:41:14.478000+02:00,55436,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:41:15.029000+02:00,55415,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top +1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:41:19.516000+02:00,54749,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top+1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:41:19.756000+02:00,55791,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top +1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:41:23.544000+02:00,55812,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        retrn s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:41:39.413000+02:00,55992,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
        """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:41:39.417000+02:00,56190,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
       """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:41:39.649000+02:00,56192,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
    """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:41:39.653000+02:00,56213,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
   """"""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:41:40.015000+02:00,56215,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.
""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:41:48.189000+02:00,56307,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
                if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:41:48.193000+02:00,56492,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
               if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:42:04.638000+02:00,56494,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:42:39.093000+02:00,56763,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:42:39.097000+02:00,56893,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
            last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:42:48.037000+02:00,56895,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index +== 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:43:03.617000+02:00,57095,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cananize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:43:03.864000+02:00,57245,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _cannize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:43:16.238000+02:00,57266,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    df _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:43:33.065000+02:00,57465,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node))
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:43:46.433000+02:00,57682,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node)
        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:43:46.451000+02:00,57839,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node)
        e = Edge(edge.first_char_index, 
        edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:43:48.551000+02:00,57868,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node)
        e = Edge(edge.first_char_index, 
                 edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:43:48.570000+02:00,58028,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node)
        e = Edge(edge.first_char_index, 
                 edge.first_char_index + suffix.length,
                  suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:43:51.430000+02:00,58057,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node)
        e = Edge(edge.first_char_index, 
                 edge.first_char_index + suffix.length,
                 suffix.source_node_index, len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:43:51.447000+02:00,58178,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node)
        e = Edge(edge.first_char_index, 
                 edge.first_char_index + suffix.length,
                 suffix.source_node_index,
                  len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:44:04.870000+02:00,58207,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node)
        e = Edge(edge.first_char_index, 
                 edge.first_char_index + suffix.length,
                 suffix.source_node_index,
                 len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:44:50.010000+02:00,58380,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node)
        e = Edge(edge.first_char_index, 
                 edge.first_char_index + suffix.length,
                 suffix.source_node_index,
                 len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:44:50.936000+02:00,58588,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node)
        e = Edge(edge.first_char_index, 
                 edge.first_char_index + suffix.length,
                 suffix.source_node_index,
                 len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn
         string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:44:51.585000+02:00,58380,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node)
        e = Edge(edge.first_char_index, 
                 edge.first_char_index + suffix.length,
                 suffix.source_node_index,
                 len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring inn string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:44:56.440000+02:00,59044,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node)
        e = Edge(edge.first_char_index, 
                 edge.first_char_index + suffix.length,
                 suffix.source_node_index,
                 len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
        is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:44:56.619000+02:00,59240,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node)
        e = Edge(edge.first_char_index, 
                 edge.first_char_index + suffix.length,
                 suffix.source_node_index,
                 len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
         is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:44:56.773000+02:00,59261,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node)
        e = Edge(edge.first_char_index, 
                 edge.first_char_index + suffix.length,
                 suffix.source_node_index,
                 len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
          is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:45:00.884000+02:00,59282,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node)
        e = Edge(edge.first_char_index, 
                 edge.first_char_index + suffix.length,
                 suffix.source_node_index,
                 len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
           is not found.
        """"""
        if not substring:
            return -1
        if self.ase_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:45:06.320000+02:00,59485,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node)
        e = Edge(edge.first_char_index, 
                 edge.first_char_index + suffix.length,
                 suffix.source_node_index,
                 len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
           is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        whille i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
2022-10-11 19:45:31.917000+02:00,59712,6.ipynb,51515,461793430,"#%% md
Please find and fix **typos and tabulation errors** in the code below. All errors are NOT about code logic.
Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking.When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task” which goes right after “Help”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.
#%%
# https://github.com/kvh/Python-Suffix-Tree

class Node(object):
    """"""A node in the suffix tree.

       suffix_node
           the index of a node with a matching suffix, representing a suffix link.
           -1 indicates this node has no suffix link.
    """"""
    def __init__(self):
        self.suffix_node = -1

    def __repr__(self):
        return ""Node(suffix link: %d)"" % self.suffix_node

class Edge(object):
    """"""An edge in the suffix tree.
       first_char_index
           index of start of string part represented by this edge
       last_char_index
           index of end of string part represented by this edge
       source_node_index
           index of source node of edge
       dest_node_index
           index of destination node of edge
    """"""
    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index
        self.source_node_index = source_node_index
        self.dest_node_index = dest_node_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def __repr__(self):
        return 'Edge(%d, %d, %d, %d)' % (self.source_node_index, self.dest_node_index,
                                         self.first_char_index, self.last_char_index)


class Suffix(object):
    """"""Represents a suffix from first_char_index to last_char_index.
       source_node_index
           index of node where this suffix starts
       first_char_index
           index of start of suffix in string
       last_char_index
           index of end of suffix in string
    """"""
    def __init__(self, source_node_index, first_char_index, last_char_index):
        self.source_node_index = source_node_index
        self.first_char_index = first_char_index
        self.last_char_index = last_char_index

    @property
    def length(self):
        return self.last_char_index - self.first_char_index

    def explicit(self):
        """"""A suffix is explicit if it ends on a node. first_char_index
           is set greater then last_char_index to indicate this.
        """"""
        return self.first_char_index > self.last_char_index

    def implicit(self):
        return self.last_char_index >>= self.first_char_index


class SuffixTree(object):
    """"""A suffix tree for string matching. Uses Ukkonen's algorithm
       for construction.
    """"""
    def __init__(self, string, case_insensitive=False)
        """"""
        string
            the string for which to construct a suffix tree
        """"""
        self.string = string
        self.case_insensitive = case_insensitive
        self.N = len(string) - 1
        self.nodes = [Node()]
        self.edges = {}
        self.active = Suffix(0, 0, -1)
        if self.case_insensitive:
            self.string = self.string.lower()
        for i in range(len(string)):
            self._add_prefix(i)

    def __repr__(self):
        """"""
        Lists edges in the suffix tree
        """"""
        curr_index = self.N
        s = ""\tStart \tEnd \tSuf \tFirst \tLast \tString\n""
        values = list(self.edges.values())
        values.sort(key=lambda x: x.source_node_index)
        for edge in values:
            if edge.source_node_index == -1:
                continue
            s += ""\t%s \t%s \t%s \t%s \t%s \t"" % (edge.source_node_index, 
                                                  edge.dest_node_index,
                                                  self.nodes[edge.dest_node_index].suffix_node,
                                                  edge.first_char_index,
                                                  edge.last_char_index)


            top = min(curr_index, edge.last_char_index)
            s += self.string[edge.first_char_index:top + 1] + ""\n""
        return s

    def _add_prefix(self, last_char_index):
        """"""The core construction method.""""""
        last_parent_node = -1
        while True:
            parent_node = self.active.source_node_index
            if self.active.explicit():
                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:
                    # prefix is already in tree
                    break
            else:
                e = self.edges[self.active.source_node_index, self.string[self.active.first_char_index]]
                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:
                    # prefix is already in tree
                    break
                parent_node = self._split_edge(e, self.active)


            self.nodes.apend(Node())
            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)
            self._insert_edge(e)

            if last_parent_node > 0:
                self.nodes[last_parent_node].suffix_node = parent_node
                last_parent_node = parent_node

            if self.active.source_node_index == 0:
                self.active.first_char_index += 1
            else:
                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node
            self._canonize_suffix(self.active)
        if last_parent_node > 0:
            self.nodes[last_parent_node].suffix_node = parent_node
        self.active.last_char_index += 1
        self._canonize_suffix(self.active)

    def _insert_edge(self, edge):
        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge

    def _remove_edge(self, edge):
        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))

    def _split_edge(self, edge, suffix):
        self.nodes.append(Node)
        e = Edge(edge.first_char_index, 
                 edge.first_char_index + suffix.length,
                 suffix.source_node_index,
                 len(self.nodes) - 1)
        self._remove_edge(edge)
        self._insert_edge(e)
        self.nodes[e.dest_node_index].suffix_node = suffix.source_node_index  ### need to add node for each edge
        edge.first_char_index += suffix.length + 1
        edge.source_node_index = e.dest_node_index
        self._insert_edge(edge)
        return e.dest_node_index

    def _canonize_suffix(self, suffix):
        """"""This canonizes the suffix, walking along its suffix string until it
        is explicit or there are no more matched nodes.
        """"""
        if not suffix.explicit():
            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]
            if e.length <= suffix.length:
                    suffix.first_char_index += e.length + 1
                suffix.source_node_index = e.dest_node_index
                self._canonize_suffix(suffix)

    # Public methods
    def find_substring(self, substring):
        """"""Returns the index of substring in string or -1 if it
           is not found.
        """"""
        if not substring:
            return -1
        if self.case_insensitive:
            substring = substring.lower()
        curr_node = 0
        i = 0
        while i < len(substring):
            edge = self.edges.get((curr_node, substring[i]))
            if not edge:
                return -1
            ln = min(edge.length + 1, len(substring) - i)
            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:
                return -1
            i += edge.length + 1
            curr_node = edge.dest_node_index
        return edge.first_char_index - len(substring) + ln
#%% md
Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen.",126,OFF,2109410956771136522,"[2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1]"
